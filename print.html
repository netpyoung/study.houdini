<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>study.houdini</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="study.houdini">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">study.houdini</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/netpyoung/study.houdini" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="들어가며"><a class="header" href="#들어가며">들어가며</a></h1>
<ul>
<li><a href="https://www.sidefx.com/">후디니</a>는 <a href="https://www.sidefx.com/">SideFx</a>사에서 만든 노드 기반 모델링 툴로써 절차적 모델링이 가능하다</li>
<li><a href="https://www.orbolt.com/search/?q=softpackage:Houdini">https://www.orbolt.com/search/?q=softpackage:Houdini</a></li>
</ul>
<p><img src="./res/geo_detail.svg" alt="geo_detail.svg" /></p>
<ul>
<li>point</li>
<li>vertex</li>
<li>primitive</li>
<li>detail</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="조작키"><a class="header" href="#조작키">조작키</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>마우스</td><td>좌클릭 + 이동</td><td>선택</td></tr>
<tr><td></td><td>우클릭 + 이동</td><td>줌</td></tr>
<tr><td></td><td>휠클릭 + 이동</td><td>뷰 잡아서 이동</td></tr>
<tr><td></td><td>ALT 좌클릭 + 이동</td><td>복제</td></tr>
<tr><td></td><td>Enter</td><td>핸들 보여주기 ( 노드 별 다름 )</td></tr>
<tr><td>뷰모드</td><td>Space</td><td>토글 / 누른채로도 유지 가능</td></tr>
<tr><td></td><td>F</td><td>오브젝트 포커스</td></tr>
<tr><td></td><td>W</td><td>Wire 프레임</td></tr>
<tr><td></td><td>Shift + W</td><td>Shaded/Wire-overShaded</td></tr>
<tr><td></td><td>D</td><td>옵션 -  Display Option</td></tr>
<tr><td></td><td>Y</td><td>고스트 오브젝트 하이드 토글</td></tr>
<tr><td></td><td>Ctrl + B</td><td>뷰포트 전체화면</td></tr>
<tr><td></td><td>Space + B</td><td>뷰포트 4분할 (씬 뷰)</td></tr>
<tr><td></td><td>Space + G</td><td>오브젝트 중심으로 줌</td></tr>
<tr><td></td><td>Ctrl + J</td><td>토글 멀티 스냅핑</td></tr>
<tr><td>선택모드</td><td>S</td><td>토글</td></tr>
<tr><td></td><td>T</td><td>움직임(<code>T</code>ranslate)</td></tr>
<tr><td></td><td>R</td><td>회전(<code>R</code>otate)</td></tr>
<tr><td></td><td>E</td><td>스케일(scal<code>E</code>)</td></tr>
<tr><td></td><td>1</td><td>Select - Object</td></tr>
<tr><td></td><td>2</td><td>Select - Point</td></tr>
<tr><td></td><td>3</td><td>Select - Edge</td></tr>
<tr><td></td><td>4</td><td>Select - Primitive</td></tr>
<tr><td></td><td>드래그</td><td>선택</td></tr>
<tr><td></td><td>Shift + 드래그</td><td>선택 - 추가</td></tr>
<tr><td></td><td>Ctrl + 드래그</td><td>선택 - 해제</td></tr>
<tr><td></td><td>C</td><td>메뉴</td></tr>
<tr><td></td><td>Ctrl + Shift + 2 / 3/ 4</td><td>선택 변경</td></tr>
<tr><td>카메라 모드</td><td>ESC</td><td>View Tool</td></tr>
<tr><td>Viewport</td><td>1</td><td>Viewport - perspective</td></tr>
<tr><td></td><td>2</td><td>Viewport - Top</td></tr>
<tr><td></td><td>3</td><td>Viewport - Front</td></tr>
<tr><td></td><td>4</td><td>Viewport - Right</td></tr>
<tr><td></td><td>5</td><td>Viewport - UV</td></tr>
<tr><td></td><td>CTRL + 1,2,3,4,5,6,7,8</td><td>Viewport - 분할뷰</td></tr>
<tr><td>Pane</td><td>CTRL + W</td><td>Pane 닫기</td></tr>
<tr><td>Pane</td><td>CTRL + B</td><td>Pane 최대/최소화</td></tr>
<tr><td></td><td>ALT + [</td><td>Pane 세로로 줄귿기</td></tr>
<tr><td></td><td>ALT + ]</td><td>Pane 가로로 줄귿기</td></tr>
<tr><td></td><td>** ALT + 1</td><td>씬 뷰</td></tr>
<tr><td></td><td>** ALT + 2</td><td>네트워크 뷰</td></tr>
<tr><td></td><td>ALT + 3</td><td>파라메터</td></tr>
<tr><td></td><td>ALT + 4</td><td>트리</td></tr>
<tr><td></td><td>ALT + 5</td><td>텍스트포트 (여기서는 알트 단축키 안먹음)</td></tr>
<tr><td></td><td>ALT + 6</td><td>애니메이션 에디터</td></tr>
<tr><td></td><td>ALT + 7</td><td>머티리얼</td></tr>
<tr><td></td><td>** ALT + 8</td><td>지오메트리 스프레드 시트</td></tr>
<tr><td></td><td>ALT + 9</td><td>렌더뷰</td></tr>
<tr><td></td><td>ALT + 쉬프트 + W</td><td>새로운 창</td></tr>
</tbody></table>
</div>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/basics/radialmenus.html">https://www.sidefx.com/docs/houdini/basics/radialmenus.html</a></li>
</ul>
<p>X Snapping controls
C The “Current” menu. You can choose the menu on this key using the  Radial switching menu at the top of the main interface.
V View controls</p>
<h2 id="object-view"><a class="header" href="#object-view">Object View</a></h2>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/network/wire.html">https://www.sidefx.com/docs/houdini/network/wire.html</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Object View</th><th></th></tr></thead><tbody>
<tr><td>Y</td><td>가위자르기</td></tr>
<tr><td>J + 드래그</td><td>선따라 라인 생성</td></tr>
<tr><td>P</td><td>프로퍼티 보기</td></tr>
<tr><td>U</td><td>상위 노드로 이동 (<code>U</code>p)</td></tr>
<tr><td>O</td><td>네트워크 오버뷰</td></tr>
<tr><td>Z</td><td>노드 모양 // Ctrl + 드래그로 기본 노드 모양 변경 가능</td></tr>
<tr><td>C</td><td>노드 색깔 // Ctrl + 드래그로 기본 노드 색깔 변경 가능</td></tr>
<tr><td>A + 마우스 아레</td><td>노드 Layout 정렬. 노드 선택후 A키 누른상태에서 아래로 (https://siver.artstation.com/blog/zORm/houdini-blog-22-tips-and-tricks)</td></tr>
<tr><td>L</td><td>노드 Layout 정렬. 선택한것들 Layout</td></tr>
<tr><td>Shift + L</td><td>노드 Layout 정렬. 전체 Layout 정렬</td></tr>
<tr><td>.</td><td>.</td></tr>
<tr><td><strong>Shift + R</strong></td><td>입력 순서 교체</td></tr>
<tr><td>Shift + S</td><td>선 스타일 바꾸기 // wiring style change: rounded &lt;-&gt; straight</td></tr>
<tr><td>Shift + Z</td><td>그룹보기</td></tr>
<tr><td>Shift + O</td><td>Network Box</td></tr>
<tr><td>Shift + P</td><td>Sticky 노트</td></tr>
<tr><td>Shift</td><td>Shft키를 누르고 노드를 움직이면 상위노드들도 같이 이동</td></tr>
<tr><td>Shift + I</td><td>이미지 추가</td></tr>
<tr><td>Ctrl + I</td><td>Edit Background Images: Enable/Disable</td></tr>
<tr><td>Ctrl + F</td><td>노드 찾기</td></tr>
<tr><td>Alt</td><td>선을 끌어당기고 있는 상태에서 이음 노드 추가.</td></tr>
<tr><td>Alt + 노드 드래그</td><td>노드 복사</td></tr>
<tr><td>Shift + Ctrl + Alt + 노드 드래그</td><td>노드 레퍼런스 생성</td></tr>
<tr><td>Page Up / Page Down</td><td>윗노드 / 아랫노드</td></tr>
<tr><td>Ctrl + 숫자</td><td>노드에 단축키 지정. 숫자로 이동가능하게 됨</td></tr>
</tbody></table>
</div>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/network/flags.html">네트워크상 키</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Q/B</td><td>노랑색 Bypass</td></tr>
<tr><td>W</td><td>진한 보라색</td></tr>
<tr><td>E</td><td>연한 보라색 미리보기 토글</td></tr>
<tr><td><strong>R</strong></td><td>파랑색 선택된것들 돌아가며 선택</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Composite View</th><th></th></tr></thead><tbody>
<tr><td>Shift + H</td><td>Fit To Viewport</td></tr>
<tr><td>` / 1 / 2 / 3 / 4</td><td>all / r / g / b / a 채널</td></tr>
</tbody></table>
</div>
<h2 id="keyframe"><a class="header" href="#keyframe">Keyframe</a></h2>
<p>alt</p>
<h2 id="ref"><a class="header" href="#ref">Ref</a></h2>
<ul>
<li>
<p>Ctrl + Alt + Shift + Click : Hotkey Manager</p>
<ul>
<li>Spreadsheet  : Shift + B</li>
</ul>
</li>
<li>
<p>Ctrl + Alt + S : tab menu 제거</p>
</li>
<li>
<p>Alt + P : timeline 축소</p>
</li>
<li>
<p>Ctrl + E : vex 편집창</p>
</li>
<li>
<p>Ctrl + 마우스 중간 : Revert To Default</p>
</li>
<li>
<p>Ctrl + Shift + 마우스 왼쪽 : Delete Channel</p>
</li>
<li>
<p>코드 폰트 확대 축소</p>
<ul>
<li>확대: Ctrl + <code>+</code></li>
<li>축소: Ctrl + <code>-</code></li>
</ul>
</li>
</ul>
<p>Alt + 마우스 가운데 버튼 : Export Parameter to Type Properties</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="설정"><a class="header" href="#설정">설정</a></h1>
<h2 id="houdinienv"><a class="header" href="#houdinienv">houdini.env</a></h2>
<pre><code class="language-txt">C:\Users\pyoung\Documents\houdini19.5\houdini.env
</code></pre>
<pre><code class="language-ini"># houdini.env
# https://www.sidefx.com/docs/houdini/basics/config_env.html
## Windows | %HOME%/houdiniX.Y/houdini.env
## Mac     | ~/Library/Preferences/houdini/X.Y/houdini.env
## Linux   | ~/houdiniX.Y/houdini.env

# EDITOR = "C:/Program Files/Microsoft VS Code/Code.exe -w"
</code></pre>
<h2 id="환경변수"><a class="header" href="#환경변수">환경변수</a></h2>
<ul>
<li>
<p>환경변수 확인</p>
<ul>
<li>Help &gt; About Houdini &gt; Show Details</li>
</ul>
</li>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/ref/env.html">https://www.sidefx.com/docs/houdini/ref/env.html</a></p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Env</th><th></th></tr></thead><tbody>
<tr><td>$HIPFILE</td><td>hip 파일</td></tr>
<tr><td>$HIPNAME</td><td>hip파일의 확장명을 제외한 파일명 hello.hip =&gt; hello</td></tr>
<tr><td>$HIP</td><td>hip 파일이 저장된 절대경로</td></tr>
<tr><td>$JOB</td><td>project 절대경로 ( File &gt; New Project )</td></tr>
<tr><td>$HFS</td><td><code>H</code>oudini <code>F</code>ile <code>S</code>ystem. The path where Houdini is installed. Houdini reads the configuration information from $HFS/houdini.</td></tr>
<tr><td>$HH</td><td>The path to Houdini supporting scripts and files inside $HFS. Usually $HFS/houdini</td></tr>
<tr><td>$HHP</td><td>The path to Houdini’s python libraries. This will differ depending on the version of python that Houdini is built with. For example $HH/python3.7libs.</td></tr>
</tbody></table>
</div>
<p>HOUDINI_OTLSCAN_PATH</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Aliases and Variables...</td><td>Alt+Shift+V</td></tr>
</tbody></table>
</div>
<h2 id="job"><a class="header" href="#job">Job</a></h2>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/basics/project.html">https://www.sidefx.com/docs/houdini/basics/project.html</a></li>
</ul>
<h2 id="단축키"><a class="header" href="#단축키">단축키</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Edit &gt; Hotkeys</th><th></th><th></th></tr></thead><tbody>
<tr><td>Copy Parameter</td><td>/Houdini/Panes/Parameter Fields and Labels</td><td>Ctrl+Shift+C</td></tr>
<tr><td>Copy Parameters</td><td>/Houdini/Panes/Parameter Spreadsheet</td><td>Ctrl+Shift+C</td></tr>
<tr><td>Paste Copied Relative Refs</td><td></td><td>Ctrl+Shift+V</td></tr>
</tbody></table>
</div>
<h2 id="색상-조정"><a class="header" href="#색상-조정">색상 조정</a></h2>
<ul>
<li>후디니&gt; Edit &gt; Color Setting &gt; Color collection 확인</li>
</ul>
<h2 id="유닛-단위-조정"><a class="header" href="#유닛-단위-조정">유닛 단위 조정</a></h2>
<p>Edit &gt; Preference &gt; Hip File Options &gt; Unit Length(m)</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>1 unit</th></tr></thead><tbody>
<tr><td>houdini</td><td>1 meter</td></tr>
<tr><td>unity</td><td>1 meter</td></tr>
<tr><td>unreal</td><td>1 cm</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="파일"><a class="header" href="#파일">파일</a></h1>
<div class="table-wrapper"><table><thead><tr><th>분류</th><th>확장자명</th><th>설명</th><th>LICENSE</th></tr></thead><tbody>
<tr><td>씬파일</td><td>.hip</td><td><code>H</code>oudini <code>I</code>ndependent <code>P</code>ackage</td><td></td></tr>
<tr><td></td><td>.hiplc</td><td>Houdini Independent Package Limited Commercial</td><td>INDIE</td></tr>
<tr><td></td><td>.hipnc</td><td>Houdini Independent Package Non-Commercial</td><td>EDUCATION / APPRENTICE</td></tr>
<tr><td>에셋</td><td>.hda</td><td><code>H</code>oudini <code>D</code>igital <code>A</code>ssets</td><td></td></tr>
<tr><td></td><td>.hdalc</td><td>Houdini Digital Assets Limited Commercial</td><td>INDIE</td></tr>
<tr><td></td><td>.hipnc</td><td>Houdini Digital Assets Non-Commercial</td><td>EDUCATION / APPRENTICE</td></tr>
<tr><td>세션</td><td>.hess</td><td><code>H</code>oudini <code>E</code>ngine <code>S</code>ession<code>S</code>ync</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>storing Houdini geometry</th><th></th></tr></thead><tbody>
<tr><td>.geo</td><td>ASCII</td></tr>
<tr><td>.bgeo</td><td>binary</td></tr>
<tr><td>.bgeo.sc</td><td>compressed .bgeo file (using BLO<code>SC</code> compression). These are often as fast (or faster) to read/write than plain .bgeo files, and take less disk space.</td></tr>
</tbody></table>
</div>
<ul>
<li>Blosc 압축
<ul>
<li><a href="https://www.blosc.org/pages/blosc-in-depth/">https://www.blosc.org/pages/blosc-in-depth/</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hda"><a class="header" href="#hda">HDA</a></h1>
<ul>
<li>
<p>HDA</p>
<ul>
<li><code>H</code>oudini <code>D</code>igital <code>A</code>ssets</li>
</ul>
</li>
<li>
<p>OTL</p>
<ul>
<li><code>O</code>perator <code>T</code>ype <code>L</code>ibrary</li>
<li>https://www.sidefx.com/docs/hdk/_h_d_k__h_d_a_intro.html</li>
<li>OTL은 여러 HDA를 포함할 수 있고, 스크립트 연산자와 같은 다른 연산자 정의도 저장할 수 있다</li>
<li>https://www.andynicholas.com/post/hdas-or-otls</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>저장</td><td>노드 우클릭 &gt; Save Node Type 혹은 Assets &gt; Save Asset &gt; 해당 에셋</td></tr>
<tr><td>락 풀기</td><td>Allow Editing of Contents</td></tr>
<tr><td>락 걸기</td><td>Match Current Definition (주의 Revert와 같은거. Save Node Type 필수)</td></tr>
<tr><td>속성 편집</td><td>Type Properties</td></tr>
</tbody></table>
</div>
<p>File &gt; Import &gt; Houdini Digital Asset...</p>
<ul>
<li>
<p>Transform.scale을 드래그해서 Edit Parameter Interface에 넣기</p>
<ul>
<li>Subnetnetwork는 추가 가능</li>
<li>Null CONTROL에 넣으려고 하면 Node is outside subnet 라고 창이 뜨면서 추가가 안됨.
<ul>
<li>파라미터 추가 창에서 Forbid Linking Parameters from Outside this Subnet 을 체크 해제하면 추가 할 수 있음.</li>
</ul>
</li>
<li>HDA는 에는 사용 가능한것처럼 보이나 Type Properties 수정시 날라감.</li>
</ul>
</li>
<li>
<p>파라미터 필드 추가 단축키</p>
<ul>
<li>alt + 마우스 중간 쿨릭</li>
</ul>
</li>
</ul>
<p>Type Property - Copy Default From Node 현재 노드에 셋팅된걸 디폴트로</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=eS1Zob0NWbY">Introduction to HDA (Houdini Digital Asset) in Unreal Engine UE4 &amp; Houdini for Beginners</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLd959VTYXCB551P4atiY52iA14JyLsaI7">Foundation Module - All Lecture Series</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=xz3Vvy5X58U">HOUDINI 101 - 09 - Digital Assets &amp; Unreal</a></li>
<li><a href="https://ehoudiniacademy.com/foundation/">https://ehoudiniacademy.com/foundation/</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="geometry-node"><a class="header" href="#geometry-node">Geometry Node</a></h1>
<p>SOP</p>
<ul>
<li>
<p>attr</p>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/model/attributes.html">https://www.sidefx.com/docs/houdini/model/attributes.html</a></li>
</ul>
</li>
<li>
<p>기본</p>
<ul>
<li>sphere</li>
<li>box</li>
<li>grid</li>
<li>tube // cone을 만들때도 사용</li>
<li>rubbertoy</li>
<li>tommy</li>
<li>platonic(tetrahedron/cube/octahedron/icosahedron/dodecahedron/soccerball/utahteapot)</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>노드</th><th></th></tr></thead><tbody>
<tr><td>Add</td><td>점 추가 // 모델에서 점만 남기기, 점으로 선만들기</td></tr>
<tr><td>Ends</td><td>Face/Hull 탭과 같은 기능. // Close U: Unroll with Shared Points로 면 없에기</td></tr>
<tr><td>Peak</td><td>노말 방향으로 이동</td></tr>
<tr><td>Transform</td><td>트랜스폼 - 전체/그룹 // Move Centeroid To Origin도 유용</td></tr>
<tr><td>Edit</td><td>트렌스폼 -  컴포넌트 단위</td></tr>
<tr><td>Delete</td><td>지우기 - 기능 더 많음    // 패턴 및 start/end // 중간에 있는 점의 노말을 살려야할시 v@N = cross(v@up, v@side)</td></tr>
<tr><td>Blast</td><td>지우기 - 간단한</td></tr>
<tr><td>Poly Extrude</td><td>밀어내기(extrude), 그룹핑 가능</td></tr>
<tr><td>Poly Bevel</td><td>비스듬한면(bevel), 선에 점을 추가하여 아치형으로 변경</td></tr>
<tr><td>Poly Path</td><td>이어진 여러 라인을 하나의 라인으로 만듬. // 둘러싸여진 라인에서 면을 만듬</td></tr>
<tr><td>Poly Frame</td><td>TangentName에 N을 넣는. TBN 구하기 // 선의 Tangent를 노말을 할당해서 노말이 선따라 가게. (N은 포인트 번호가 낮은 방향으로 향하게 된다)</td></tr>
<tr><td>Poly Fill</td><td>채우기</td></tr>
<tr><td>Poly Split</td><td>자르기 - Edge Percentage가 유용 // 면을 자를때 좋음</td></tr>
<tr><td>Poly Cut</td><td>면없에기 // 선따기 좋음</td></tr>
<tr><td>Poly Doctor</td><td></td></tr>
<tr><td>Group</td><td>그룹핑 - 추가  // 바운딩박스로도 그룹핑 가능(ex 가운데 점만 얻기)  // 노말로 그룹핑(ex 상단 점들만)</td></tr>
<tr><td>Group Expression</td><td>그룹핑 - 표현식으로 // Union with Existing</td></tr>
<tr><td>Group Delete</td><td>그룹핑 - 삭제</td></tr>
<tr><td>Group by Range</td><td>그룹핑 - 범위 // Invert Range - 양끝점만 얻기</td></tr>
<tr><td>Group Combine</td><td>그루핑 - boolean연산</td></tr>
<tr><td>Group Transfer</td><td>그루핑 - override / distance threshold 유용</td></tr>
<tr><td>Reverse</td><td>노말 - 반대로</td></tr>
<tr><td>Normal</td><td>노말 - 스무스 효과 가능 Cusp Angle이 작을수록 하드, 클수록 소프트</td></tr>
<tr><td>Boolean</td><td>교집 - 교집합/합집합</td></tr>
<tr><td>Clip</td><td>clipping - 반으로 자르는거</td></tr>
<tr><td>ROP FBX Output</td><td>.fbx 내보내기</td></tr>
<tr><td>ROP Geometry Ouput</td><td>캐쉬 - 생성 $HIP/geo/$OS.bgeo.sc // $OS. Operator String 노드이름  // .obj내보내기</td></tr>
<tr><td>File</td><td>캐쉬 - 불러오기</td></tr>
<tr><td>File Cache</td><td>캐쉬 - 생성 / 불러오기 - 기능이 2개라 햇갈려서 잘 쓰지 않음</td></tr>
<tr><td>Attribute Create</td><td>Attribute - 생성 // 그룹에 대한 attribute 생성도 가능  // $PR 할당할때</td></tr>
<tr><td>Attribute from Map</td><td>Attribute - 이미지로부터 attribute를 가져옴</td></tr>
<tr><td>Attribute Promote</td><td>Attribute - 포인트 어트리뷰트를 프리미티브 어트리뷰트로 변환하는것 처럼 서로 다른 클래스로 어트리뷰트 전환이 가능</td></tr>
<tr><td>Attribute Transfer</td><td>Attribute - 이전. // condition을 이용해서 거리에 따른 Attribute를 가져올 수 도 있다.</td></tr>
<tr><td>Attribute Randomize</td><td>Attribute - 랜덤화</td></tr>
<tr><td>Attribute VOP</td><td>Attribute - VOP 노드에는 자체는 키를 줄 수 없다 / VOP 노드 선택&gt; VEX/VOP Options&gt; Create Input Parameters</td></tr>
<tr><td>Scatter</td><td>면에다 점찍기</td></tr>
<tr><td>Triangulate</td><td>포인트를 잘 연결해 트라이엥글로 만들어줌</td></tr>
<tr><td>Triangulate 2D</td><td>포인트를 잘 연결해 트라이엥글로 만들어줌</td></tr>
<tr><td>Resample</td><td>다시 표본화. 선에 점찍는 용도. Treat Polygons As - Subdivision Curves로 휘어짐을 표현할 수 도 있다</td></tr>
<tr><td>Polywire</td><td>와이어프레임</td></tr>
<tr><td>Curve</td><td>간단한, 베이지어 커브      // transform에서 bbox를 이용 살짝 올리고 height field에 ray랑 같이 써도 좋음</td></tr>
<tr><td>Draw Curve</td><td>그릴 수 있지만, 거칠기에 Smooth를 같이 써주는게 좋다. // Projection.Projection : Geometry도 있다</td></tr>
<tr><td>Smooth</td><td>완만하게 해주는거 커브, 리셈플이랑 주로 같이 쓰임</td></tr>
<tr><td>Carve</td><td>깍아내기 // uv로 선을 자름</td></tr>
<tr><td>Sweep</td><td>선따라 길만들기  // UVs and Attribute - Compute UVs 도 있으니 참고. //Construction - Target Up Vector에 Y Axis도 잘 활용 // 밧줄같은건 twist</td></tr>
<tr><td>Copy To Point</td><td>포인트들 위치로 복사  // attribute 삭제되는거 주의 // Pack and Instance 로 입력 Geometry단위로 Primitive로 묶을 수 있음</td></tr>
<tr><td>Copy And Transform</td><td>갯수만큼 복사 // 테두리같이 뭔가 둘러싸는 걸 만들 때도 유용 / Match Size로 위치조정</td></tr>
<tr><td>Foreach</td><td><a href="https://www.youtube.com/watch?v=xs5WezgOZlo">https://www.youtube.com/watch?v=xs5WezgOZlo</a></td></tr>
<tr><td>Platonic Solids</td><td>Tetrahedron(4)/Cube(6)/Octahedron(8)/Icosahedron(20)/Dodecahedron(12)/Soccer ball(pentagonal b12 + w20)/Utah teapot</td></tr>
<tr><td>Iso Offset</td><td>Builds an offset surface from geometry. // 볼륨변환  // Scatter랑 같이 쓰이기도함</td></tr>
<tr><td>Convert</td><td>지오메트리 -  기하학을 변환(ex 폴리곤화) // 라인을 커브로 // LOD</td></tr>
<tr><td>Remesh</td><td>지오메트리 - 메쉬 늘리기/줄이기</td></tr>
<tr><td>Remesh to Grid</td><td>merge같이 합친후 하나의 메쉬 처럼 보이도록 할때</td></tr>
<tr><td>Facet</td><td>지오메트리 - 점 또는 표면 노말을 통합 // remove inline points로 resample한걸 합칠 수 있다. // post-compute normal로 노말만들때도 사용</td></tr>
<tr><td>Fuse</td><td>각 포인트들을 거리나 Snap에 따라 <strong>합치기</strong>. 프리미티브 가운데 찾기. Normal 다시 계산하는게 기본이므로 Remove Affected Normals 확인 하자. 라인을 Grid 스냅 가능</td></tr>
<tr><td>Clean</td><td>겹쳐진 primitive 삭제가능</td></tr>
<tr><td>Divide</td><td>Don't Generate Slivers/Avoid Small Angles 동시 체크 추천. // Remove Shared Edge 엣지 지우면서 합치기 //Bricker Polygon으로 그리드도 가능</td></tr>
<tr><td>linear taper</td><td>오므라들게</td></tr>
<tr><td>Match Size</td><td>Resizes and recenters the input geometry to match a reference bounding box. // Scale To Fit 유용</td></tr>
<tr><td>Skin</td><td>두 표면사이에 스킨을 씌워준다. // Keep primitives 로 원래 모양도 유지가능</td></tr>
<tr><td>Sort</td><td>Point 나 Primitive를 정렬 혹은 랜덤 /. Shaft/Offset을 이용 오프셋 작업 가능Ï</td></tr>
<tr><td>Convert Line</td><td>포인트끼리 연결한 라인  // Join 반대라고 생각하면 됨.</td></tr>
<tr><td>Object Merge</td><td>외부 노드 불러오기</td></tr>
<tr><td>Visualize Attribute</td><td>Attribute 기반 시각화 / TBN(rgb)을 시각화 시키면 좋다 / Type : Marker - Style : Vector</td></tr>
<tr><td>Pack</td><td>Pack하면 Point 1개와 Primitive 1개로 처리(foreach돌때 좋을듯) / 게임엔진에서 별도의 메쉬로 취급</td></tr>
<tr><td>Unique Points/Point Split</td><td>Splits points shared by multiple vertices, optionally only if the vertices differ in attribute value. / PolyWire랑 쓰면 좋음</td></tr>
<tr><td>Paint</td><td>페인팅</td></tr>
<tr><td>Point</td><td>어트리뷰트 생성 ( point )   // 포인트에 Cd어트리 뷰트 생성시 유용</td></tr>
<tr><td>Point Jitter</td><td></td></tr>
<tr><td>Measure</td><td>area 계산</td></tr>
<tr><td>Lattice</td><td>공간 왜곡/휘기</td></tr>
<tr><td>Dissolve</td><td>https://www.sidefx.com/docs/houdini/nodes/sop/dissolve</td></tr>
<tr><td>PolyExpand2D</td><td>밖 혹은 안으로 (ex quad 확장/축소)</td></tr>
<tr><td>PolyReduce</td><td>LOD</td></tr>
<tr><td>PolyBridge</td><td>떨어진걸 이어줌 // 이상하게 이어져 있으면 Paring - Interpolation : Linear 확인</td></tr>
<tr><td>Bound</td><td>box/sphere/rectangle의 바운딩 박스를 만듬</td></tr>
<tr><td>Extract Centroid</td><td>센터 구하기</td></tr>
<tr><td>exploded view</td><td>쪼개서 넓히기</td></tr>
<tr><td>subdivide</td><td>나누기. // 선의 중앙점도 쉽게 구할 수 있다</td></tr>
<tr><td>font</td><td>텍스트 쓰기 text</td></tr>
<tr><td>Intersection Stitch</td><td>ex 선 겹칠때 접점을 기준으로 나누기. 교차로</td></tr>
<tr><td>Primitive Properties</td><td>Primitive의 수치 조정. 각 프리미티브 회전 등등</td></tr>
<tr><td>Distance along Geometry</td><td>https://www.sidefx.com/docs/houdini/nodes/sop/distancealonggeometry.html</td></tr>
<tr><td>Orientation Along Curve</td><td>선따라 N 셋팅</td></tr>
<tr><td>Labs Edge Group To Curve</td><td>태두리 구하기</td></tr>
<tr><td>Labs Dissolve Flat Edges</td><td></td></tr>
<tr><td>Switch / Switch-If</td><td></td></tr>
<tr><td>Labs Detail Mesh</td><td>uv한 오브젝트에 다른 패턴를 프로젝트하여 디테일을 살림</td></tr>
<tr><td>helix</td><td>나선</td></tr>
<tr><td>Connect Adjacent Pieces</td><td>점끼리 선이을때</td></tr>
</tbody></table>
</div>
<p>Edge Straighten</p>
<p>shrinkwrap 랩핑하기 triangulate2d 랑 비슷한
Refine</p>
<p>Chain - Copy To Point랑 비슷한데 start/end 지정할 수 있음.
Box Cutter : 박스모양으로 자름 Boolean이랑 비슷함
Physical Painter : 물체위에 물체붙이기
Thicken : 양옆으로 늘어나기 - poly extrude는 한쪽이지만</p>
<p>Labs Instance Attribute : 디버그용. xyz표시되는 gizmo가 유용하다
Labs symmetrize : mirror랑 비슷</p>
<p>Extract Silhouette Y축으로 하면 위에서 아래로 내려다 보는 (실루엣)면을 얻을 수 있음.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Merge</td><td>합치기. 필요에 따라 Fuse를 뒤에 붙여 중복 제거</td></tr>
<tr><td>Soft Transform</td><td>부드러운 곡선</td></tr>
<tr><td>Join</td><td>선들 머지해서 연결작업(후처리)/선 끝을 서로 연결 // 떨어져있는 선 각각 프리미티브 합치기(Only Connected)</td></tr>
<tr><td>Mirror</td><td>좌우 대칭. 라인 두개를 Skin하는 경우 Reverse: No Change 고려 할 것</td></tr>
<tr><td>Revolve</td><td>중심 축을 중심으로 곡선을 회전하여 표면을 만듬. (ex 유리잔)</td></tr>
</tbody></table>
</div>
<ul>
<li>NURBS(Non-uniform rational basis spline)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>foreach</th><th></th></tr></thead><tbody>
<tr><td>iteration</td><td>0, 1, 2 ...</td></tr>
<tr><td>numiterations</td><td>1, 2, 3 ...</td></tr>
<tr><td>ivalue</td><td>start + increment * iteration</td></tr>
<tr><td>value</td><td>start + increment * iteration</td></tr>
</tbody></table>
</div>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/copy/tutorial_stamping.html">https://www.sidefx.com/docs/houdini/copy/tutorial_stamping.html</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Primitive Type</th><th></th></tr></thead><tbody>
<tr><td>Primitive</td><td></td></tr>
<tr><td>Polygon</td><td>삼각형</td></tr>
<tr><td>Polygon Mesh</td><td>사각형</td></tr>
<tr><td>Mesh</td><td></td></tr>
<tr><td>NURBS</td><td></td></tr>
<tr><td>Beizer</td><td></td></tr>
<tr><td>Polygon Soup</td><td></td></tr>
</tbody></table>
</div>
<h2 id="attribute-vop"><a class="header" href="#attribute-vop">Attribute VOP</a></h2>
<ul>
<li>Bind 노드로 attribute 노출 가능.</li>
<li>Constant로 연산시 캐스팅 주의 ( int 1.0 + float 0.5 = int 1로 되어버리는 경우가 있음 )</li>
</ul>
<h2 id=""><a class="header" href="#"></a></h2>
<p>Point From Volume 액체 제작할때 많이 사용. 단독=&gt; Geo, VDB from Polygon =&gt; SDF, Iso Offset =&gt; Fog
Iso Offset 연기</p>
<p>Particle Fluid Surface</p>
<p>DOP Network
VDB</p>
<p>smoke / fire / pyro</p>
<h2 id="pop-network-시뮬레이션"><a class="header" href="#pop-network-시뮬레이션">Pop Network 시뮬레이션</a></h2>
<p>POP Object POP환경에 맞게 일반 파티클 시스템을 동적 오브젝트로 변환.
POP Solver 타임스탭에 맞게 파티클을 업데이트
POP Source generates particles from geometry.</p>
<h2 id="etc"><a class="header" href="#etc">etc</a></h2>
<p>후면 틴트: Display Options: Markers / Primitives / Tint Backfaces
Display Options : Guids / Origin gnomon</p>
<h2 id="foreach"><a class="header" href="#foreach">foreach</a></h2>
<p>https://www.sidefx.com/docs/houdini/nodes/sop/block_begin.html
https://www.sidefx.com/docs/houdini/nodes/sop/block_end.html</p>
<div class="table-wrapper"><table><thead><tr><th>Begin - Method</th><th></th></tr></thead><tbody>
<tr><td>Fetch Feedback</td><td></td></tr>
<tr><td>Extract Piece or Point</td><td></td></tr>
<tr><td>Fetch Metadata</td><td>빈 지오메트리</td></tr>
<tr><td>Fetch Input</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>End - Iteration Method</th><th></th></tr></thead><tbody>
<tr><td>By Piece or Points</td><td></td></tr>
<tr><td>By Count</td><td>반복 횟수 지정</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>End - Gather Method</th><th></th></tr></thead><tbody>
<tr><td>Feadback Each Iteration</td><td></td></tr>
<tr><td>Merge Each Iteration</td><td></td></tr>
</tbody></table>
</div>
<h2 id="-1"><a class="header" href="#-1"></a></h2>
<p>Decal Projector
https://www.sidefx.com/docs/houdini/nodes/sop/labs--decal_projector.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uv"><a class="header" href="#uv">UV</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Seams 경계선</th><th></th></tr></thead><tbody>
<tr><td>UV Autoseam</td><td></td></tr>
<tr><td>Group</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>UV Create</th><th></th></tr></thead><tbody>
<tr><td>UV Project</td><td>프로젝션 기법을 이용하여 UV 전개. 복잡한 봉같은 건 그룹(Boundary)로 자르고 원통형 Cylinder</td></tr>
<tr><td>UV Flatten</td><td>flattening constraints// Seam(이음매), Rectify(바로잡다) 잘 활용</td></tr>
<tr><td>AutoUV</td><td>SideFXLab 에 통합됨</td></tr>
<tr><td>UV Unwrap</td><td>자동 uv 평탄화 및 구릅핑</td></tr>
<tr><td>UV Texture</td><td>평면은 물론, 구형이나 원통형을 UV 전개</td></tr>
<tr><td>Sweep</td><td></td></tr>
<tr><td>UV Pelt</td><td></td></tr>
<tr><td>Labs UV Unwrap Cylinder</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>UV Editing</th><th></th></tr></thead><tbody>
<tr><td>UV Edit</td><td></td></tr>
<tr><td>UV Transform</td><td></td></tr>
<tr><td>UV Fuse</td><td></td></tr>
<tr><td>UV Layout</td><td>uv 그룹 배치 - Scale Islands to Match Their Surface Areas</td></tr>
<tr><td>UV Smooth</td><td></td></tr>
<tr><td>UV Brush</td><td></td></tr>
<tr><td>Labs UV Unitize</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Validation</th><th></th></tr></thead><tbody>
<tr><td>Labs UV Distortion</td><td></td></tr>
<tr><td>Labs Calculate UV Distortion</td><td></td></tr>
<tr><td>Labs UV Remove Overlap</td><td></td></tr>
<tr><td>Labs Texel Density</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Preview</th><th></th></tr></thead><tbody>
<tr><td>UV QuickShade</td><td>평면 // grid 한장</td></tr>
<tr><td>Labs UV Visualize</td><td>UV 시각화   // Visualize UV Islands / Visualize Seams도 있다</td></tr>
<tr><td>Labs Export UV Wireframe</td><td></td></tr>
</tbody></table>
</div>
<p>sphere - uvproject (polar)</p>
<ul>
<li>UV Layout
<ul>
<li>Connectivity
<ul>
<li>Seperate Edges - 액자같은거 Group으로 edge잘라서</li>
<li>Island Attribute - Copy같이 여러개 만들었을때 attribute 만들고 unpack (transfer attribute)하고</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>udim
https://www.sidefx.com/docs/houdini/solaris/udim.html
UDIM is a system for dividing texture space into multiple “tiles” in UV space, with each tile represented by a separate texture file on disk.</p>
<p><img src="node/geometry/../../res/udim.svg" alt="" /></p>
<ul>
<li>1001 기준
<ul>
<li>1만큼 옆으로(U)</li>
<li>10만큼 위로(V)</li>
</ul>
</li>
</ul>
<hr />
<p>Labs Automatic Trim Texture
Labs Trim Texture</p>
<h3 id="uv-펴기"><a class="header" href="#uv-펴기">UV 펴기</a></h3>
<h4 id="tube"><a class="header" href="#tube">Tube</a></h4>
<ul>
<li>UV Project
<ul>
<li>Projection: Cylindrical</li>
<li>Translate: centroid(opinputpath(".", 0), D_X) | centroid(opinputpath(".", 0), D_Y) | centroid(opinputpath(".", 0), D_Z)</li>
<li>Scale: ch("../main_shape/radscale") * 2 | ch("../main_shape/height") * 2 | ch("../main_shape/radscale") * 2</li>
</ul>
</li>
</ul>
<h2 id="ref-1"><a class="header" href="#ref-1">ref</a></h2>
<ul>
<li>
<p><a href="https://youtu.be/Up97rAuXBwU?t=1306">Directed Procedural Workflows with Houdini and Unity</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=YFXdTfdrT4Y">Introduction to Houdini 16: Simple Procedural UVs</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=T80MY8Qaxp0">Houdini Tutorial - Under 10 Minutes - How to UV Map complex geometry</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=DN95J9ORp90">Tools in Houdini for normal baking tutorial. Part 1</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=xMwuKEenr4M">Transfer texture maps to new UV coordinates in Houdini</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=7kUDLsNn0iA">Procedural UVs - UV Layout Node in Depth</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=VNX9Qf6a5hs">Houdini Unwrapping Techniques: The Basics</a></p>
</li>
<li>
<p><a href="https://qiita.com/jyouryuusui/items/e15d53e88e9cc018d18f">https://qiita.com/jyouryuusui/items/e15d53e88e9cc018d18f</a></p>
</li>
<li>
<p><a href="https://www.technical-artist.net/?p=111">https://www.technical-artist.net/?p=111</a></p>
</li>
</ul>
<p><a href="https://www.youtube.com/watch?v=pas33fBP8Dg">Split UV shells</a></p>
<p><a href="https://www.youtube.com/watch?v=Phz3BTwFWRg">Houdini Tutorial: Closed Sweep Spline and keep UVs</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="step"><a class="header" href="#step">Step</a></h1>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/io/ocio.html">https://www.sidefx.com/docs/houdini/io/ocio.html</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>점 추가</td><td>Add</td></tr>
<tr><td>모델에서 점만 남기기</td><td></td></tr>
<tr><td>점으로 선만들기</td><td></td></tr>
<tr><td>선에 점을 추가하여 아치형으로 변경</td><td>PolyBevel</td></tr>
</tbody></table>
</div>
<h2 id="배우기"><a class="header" href="#배우기">배우기</a></h2>
<ul>
<li>카피 파라메터</li>
<li>인스펙터 수정</li>
<li>디스플레이뷰 점사이즈/숫자</li>
</ul>
<h2 id="아치형"><a class="header" href="#아치형">아치형</a></h2>
<ul>
<li>그리드 1x1 // 2-2</li>
<li>그룹 @P.y &gt; 0</li>
<li>베벌 distance 0.5</li>
<li>퓨즈</li>
</ul>
<h2 id="채우기"><a class="header" href="#채우기">채우기</a></h2>
<ul>
<li>중심축을 정해 transform해서 띄워주고</li>
<li>mirror - reverse normal : No</li>
<li>skin</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="스크립트"><a class="header" href="#스크립트">스크립트</a></h1>
<div class="table-wrapper"><table><thead><tr><th>종류</th><th>확장자</th><th>기타</th></tr></thead><tbody>
<tr><td><a href="https://www.sidefx.com/docs/houdini/hom/index.html">Python     </a></td><td>.py</td><td></td></tr>
<tr><td><a href="https://www.sidefx.com/docs/houdini/vex/index.html">VEX        </a></td><td>.vlf/.vex</td><td></td></tr>
<tr><td><a href="https://www.sidefx.com/docs/houdini/expressions/index.html">expressions</a></td><td></td><td>느림</td></tr>
<tr><td><a href="https://www.sidefx.com/docs/houdini/commands/index.html">HScript    </a></td><td></td><td>옛날꺼</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="vex"><a class="header" href="#vex">VEX</a></h1>
<ul>
<li>VEX(<code>V</code>ector <code>EX</code>pressions)</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Vex</th><th></th></tr></thead><tbody>
<tr><td>vex</td><td></td></tr>
<tr><td>h</td><td>#include&lt;&gt; 용</td></tr>
<tr><td>vfl</td><td>Vex Function Library</td></tr>
<tr><td>pragma</td><td>vex 전용 <a href="https://www.sidefx.com/docs/houdini/vex/pragmas.html">pragma</a></td></tr>
<tr><td>ds</td><td>Dialog Script</td></tr>
<tr><td>houdini.env</td><td></td></tr>
</tbody></table>
</div>
<p>int  assert_enabled()
Returns 1 if the environment variable HOUDINI_VEX_ASSERT is set or 0 if the variable isn’t set.
https://www.sidefx.com/docs/houdini/vex/assertions.html
assert(1 == 2);
assert(0 == 0);</p>
<h2 id="에디터-설정"><a class="header" href="#에디터-설정">에디터 설정</a></h2>
<ul>
<li>Edit &gt; Preference &gt; Set External Text Editor</li>
<li>VEXpression &gt; 우클릭 &gt; Expression &gt; Edit in External Editor</li>
<li>Visual Studio Code에 VEX 플러그인</li>
</ul>
<pre><code class="language-ini">// C:\Users\ (UserName) \Documents\houdini19.0\houdini.env

EDITOR = "C:\Users\(UserName)\AppData\Local\Programs\Microsoft VS Code\Code.exe"
</code></pre>
<h2 id="노드"><a class="header" href="#노드">노드</a></h2>
<ul>
<li>
<p>Attribute VOP</p>
<ul>
<li>Vex 시각화 그래프</li>
</ul>
</li>
<li>
<p>Attribute Wrangle</p>
<ul>
<li>Vex 코딩</li>
<li>Wrangle뜻
<ul>
<li>다루다. 소나 말들 관리</li>
<li><a href="https://english.stackexchange.com/questions/263712/what-does-come-on-lets-wrangle-up-the-cattle-mean">https://english.stackexchange.com/questions/263712/what-does-come-on-lets-wrangle-up-the-cattle-mean</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>세미콜론(;) 붙여야함</p>
</li>
<li>
<p>주석</p>
<ul>
<li>//</li>
<li>/* ... */</li>
</ul>
</li>
</ul>
<h2 id="typeattribute"><a class="header" href="#typeattribute">type@attribute</a></h2>
<ul>
<li>geometry sheet에서 확인 가능</li>
</ul>
<pre><code class="language-vex">i@myint         = 5;                                        // i | int

f@myfloat       = 12.234;                                   // f | float
u@myvector2     = {0.6, 0.5};                               // u | vector2
v@myvector      = {1,2,3};                                  // v | vector
p@myquat        = {0,0,0,1};                                // p | vector4

2@mymatrix2     = {1,2,3,4};                                // 2 | matrix2
3@mymatrix3     = {1,2,3,4,5,6,7,8,9};                      // 3 | matrix3
4@mymatrix4     = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}; // 4 | matrix

s@mystring      = 'a string';                               // s | string

d@mydict        = {};                                       // d | dict
d@mydict['key'] = 'value';

dict s = {};

i[]@connected_pts = neighbours(0, @ptnum);                  // i[] | int[] array

// 정의 후 @attribute 형태로 쓸 수 있다.
// { ... } 과 set( ... ) 는 동일.



// 배열이 좀 특이함
function int[] HelloWorld(int a[])
{
  int ret[];
  return ret;
}

// boolean형이 없네
</code></pre>
<pre><code class="language-vex">vector x0 = point(0, "P", @ptnum);
vector x1 = point(1, "P", @ptnum);


float dist = distance(x0, x1);
vector dir = normalize(x1 - x0);
vector next = x0 + dir * (dist / 2.0f);

@P = next;
</code></pre>
<h2 id="-2"><a class="header" href="#-2">@</a></h2>
<h2 id="xx"><a class="header" href="#xx">xx</a></h2>
<pre><code class="language-vex">
@P                     =&gt; points
@N                     =&gt; normals
@Cd                    =&gt; primvars:displayColor
@id                    =&gt; ids
@width,@widths,@pscale =&gt; widths
@v                     =&gt; velocities
@w                     =&gt; angularVelocities
@accel                 =&gt; accelerations
@uv                    =&gt; primvars:st
@Alpha                 =&gt; primvars:displayOpacity


v@N; // the normal. If this hasn't been set, vex will calculate it for you just by calling it without initialised values
v@up; // a vector to control the spin around the normal when using instancing/copytopoints/etc
p@orient; // vector4 used as explicit rotation for instances
3@transform; // matrix3 used to control rotation and scale for instances
4@localtransform; // matrix (4x4) used for kinefx joints
f@pscale; // uniform scale for instances
v@scale; // XYZ scale control for instances

v@P; // current elements position. can be set for points, can be read for vertices and prims. Prims will guess the midpoint, not always reliable!
v@Cd; // diffuse colour
</code></pre>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>@elemnum</td><td>현재 element</td><td>@id</td></tr>
<tr><td>@vtxnum</td><td>현재 vertex (linear)</td><td>흔히 말하는 버텍스</td></tr>
<tr><td>@ptnum</td><td>현재 point</td><td>포인트(중복된 포지션이 없다)</td></tr>
<tr><td>@primnum</td><td>현재 primitive</td><td>단일 엔티티(면 or 구 ...)</td></tr>
<tr><td>@numelem</td><td>총 element 갯수</td><td></td></tr>
<tr><td>@numvtx</td><td>총 vertex 갯수</td><td></td></tr>
<tr><td>@numpt</td><td>총 point 갯수</td><td></td></tr>
<tr><td>@numprim</td><td>총 primitive 갯수</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>@Time</td><td>Float time ($T)</td></tr>
<tr><td>@Frame</td><td>Float frame ($FF)   // $F는 int frame</td></tr>
<tr><td>@SimTime</td><td>Float simulation time ($ST), only present in DOP contexts.</td></tr>
<tr><td>@SimFrame</td><td>Float simulation frame ($SF), only present in DOP contexts.</td></tr>
<tr><td>@TimeInc</td><td>Float time step (1/$FPS)</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>$VTX</td><td>vertexprimindex(0, @vtxnum);</td></tr>
</tbody></table>
</div>
<h2 id="geometry-attribute"><a class="header" href="#geometry-attribute">geometry attribute</a></h2>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/model/attributes.html">https://www.sidefx.com/docs/houdini/model/attributes.html</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Geometry</th><th></th><th></th></tr></thead><tbody>
<tr><td>@id</td><td>int</td><td>A unique element ID</td></tr>
<tr><td>@name</td><td>string</td><td>이름</td></tr>
<tr><td>@P</td><td>vector</td><td>포지션</td></tr>
<tr><td>@N</td><td>vector</td><td>노말</td></tr>
<tr><td>@v</td><td>vector</td><td>속도 Velocity</td></tr>
<tr><td>@piece</td><td>int</td><td>조각</td></tr>
<tr><td>@pscale</td><td>float</td><td>Uniform scaling factor</td></tr>
<tr><td>@scale</td><td>vector</td><td>Whereas pscale is a single uniform scaling factor in all axes</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Rendering</th><th></th><th></th></tr></thead><tbody>
<tr><td>@uv</td><td>vector</td><td>UV</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Shader</th><th></th><th></th></tr></thead><tbody>
<tr><td>@Cd</td><td>vector</td><td>diffuse 색깔</td></tr>
<tr><td>@Cs</td><td>vector</td><td>specular 색깔</td></tr>
<tr><td>@Cr</td><td>vector</td><td>reflect 색깔</td></tr>
<tr><td>@Ce</td><td>vector</td><td>emission 색깔</td></tr>
<tr><td>@Ct</td><td>vector</td><td>transmit 색깔</td></tr>
<tr><td>@Alpha</td><td>float</td><td>Alpha transparency override. The viewport uses this to set the alpha of OpenGL geometry.</td></tr>
<tr><td>@rough</td><td>float</td><td>Roughness override.</td></tr>
<tr><td>@fresnel</td><td>float</td><td>Fresnel coefficient override.</td></tr>
<tr><td>@shadow</td><td>float</td><td>Shadow intensity override.</td></tr>
<tr><td>@sbias</td><td>float</td><td>Shadow bias override.</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Particle</th><th></th><th></th></tr></thead><tbody>
<tr><td>@orient</td><td>vector4</td><td>Quaternion orientation of a particle</td></tr>
<tr><td>@up</td><td>vector</td><td>Represents the up vector of a particle’s local space</td></tr>
<tr><td>@rot</td><td>vector4</td><td>An additional offset-quaternion applied after all other attributes</td></tr>
</tbody></table>
</div>
<h2 id="ch"><a class="header" href="#ch">ch</a></h2>
<ul>
<li>
<p>파라미터 삭제시: More &gt; Delete Spare Parameter</p>
</li>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/vex/functions/ch.html">https://www.sidefx.com/docs/houdini/vex/functions/ch.html</a></p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>ch</th><th></th></tr></thead><tbody>
<tr><td>chf</td><td>float</td></tr>
<tr><td>chi</td><td>int</td></tr>
<tr><td>chv</td><td>vector</td></tr>
<tr><td>chramp(channel,ramppos, time)</td><td>조절 가능한 2차원 그래프 채널이 생긴다</td></tr>
</tbody></table>
</div>
<h2 id="quaternion"><a class="header" href="#quaternion">quaternion</a></h2>
<ul>
<li>Quaternions
<ul>
<li><a href="https://youtu.be/en2QcehKJd8?si=Fgbr6dk2GIrzgmP_">Math in Game Development Summit: A Visual Guide to Quaternions and Dual Quaternions</a></li>
</ul>
</li>
</ul>
<pre><code class="language-vex">vector4 orient = quaternion(maketransform(@N, @up));
vector euler  = quaterniontoeuler(orient,XFORM_XYZ);
v@rot = degrees(euler);
</code></pre>
<pre><code class="language-vex">// maketransform: https://www.sidefx.com/docs/houdini/vex/functions/maketransform.html

vector4  quaternion(matrix3 rotations)
vector4  quaternion(float angle, vector axis)
vector4  quaternion(vector angleaxis)

vector  qrotate(vector4 quaternion, vector v)
vector  degrees(vector nums_in_rads)
vector  quaterniontoeuler(vector4 orient, int order)

vector4  slerp(vector4 q1, vector4 q2, float bias)

vector4  qmultiply(vector4 q1, vector4 q2)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Constant name</th><th>Rotation Order</th></tr></thead><tbody>
<tr><td>XFORM_XYZ</td><td>Rotate order X, Y, Z</td></tr>
<tr><td>XFORM_XZY</td><td>Rotate order X, Z, Y</td></tr>
<tr><td>XFORM_YXZ</td><td>Rotate order Y, X, Z</td></tr>
<tr><td>XFORM_YZX</td><td>Rotate order Y, Z, X</td></tr>
<tr><td>XFORM_ZXY</td><td>Rotate order Z, X, Y</td></tr>
<tr><td>XFORM_ZYX</td><td>Rotate order Z, Y, X</td></tr>
<tr><td>XFORM_TRS</td><td>Translate, Rotate, Scale</td></tr>
</tbody></table>
</div>
<h2 id="etc-1"><a class="header" href="#etc-1">Etc</a></h2>
<pre><code class="language-vex">point("../OUT_P", 0, "P", 1)  // OUT_P  노드의 0번째의 point P의 Y좌표(xyz / 012)
npoints(0) // 0번입력의 포인트 갯수
addpoint // removepoint
pointattrib - point랑 비슷한데 끝에 success받음. 네이밍이 조금 혼잡하네
setpointattrib
setpointgroup

opdigits(".")                 // 현재 노드(".")의 이름의 숫자만 가져옴
rand(x)                       // 랜덤. 분포가 일정하게 되는데 그럴때 사칙연산을 내부적으로 넣어주기도 함
rand(seed1, seed2)            // seed2가 있는데. 보통 rand(seed + 1)처럼 고유값을 갖기위한 패턴이 있는데 이걸 rand(seed, 1)처럼 쓸 수 있다.

chramp("radius_ramp", @curveu)    // 기어버튼으로 추가된 radius_ramp curveu의 위치 값을 가져온다
detail("../META/", "iteration", 0) // META에 있는 iteration의 0번째 값





prim("../OUT_Cd", 2, "Cd", 0) // OUT_Cd 노드의 2번째의 primitive Cd의 Red채널값(rgb / 012)
nprims(0) // 0번입력의 프라임 갯수
addprim  // removeprim
setprimattrib
setprimgroup

primintrinsic // Reads a primitive intrinsic from a geometry.

addvertex




getpointbbox_center(input)
</code></pre>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>clamp(value, min, max)</td><td></td></tr>
<tr><td>fit(value, fromMin, fromMax, toMin, toMax)</td><td></td></tr>
<tr><td>point(geometry, attribute_name, pointnumber)</td><td>geometry는 입력 순서(0부터)</td></tr>
<tr><td>포지션 - minpos(geometry, point)</td><td>point에서 geometry에 레이를 쐈을시 가장 먼저 닿는 부분의 포지션</td></tr>
<tr><td>포인트 - nearpoint(geometry, pt)</td><td>geometry에 있는 모든 point 중에서 pt와 가장 가까운 point의 번호</td></tr>
<tr><td>Vector getbbox_size(geometry)</td><td>Computes the size of the bounding box for the geometry.</td></tr>
</tbody></table>
</div>
<p>getbbox_max</p>
<pre><code class="language-vex">vector currP = @P;

// 현재 위치에서 1번 지오메트리와 맨 처음으로 마주치게될 포지션.
vector hittedP = minpos(1, currP);

// 현재 위치에서 1번 지오메트리에 있는 모든 포인트 중 가장 가까운 포인트번호.
int nearPointNumber = nearpoint(1, currP);

// 1번 지오메트리의 nearpointNumber의 _id값.
int id = point(1, "_id", nearPointNumber);
</code></pre>
<p>float xyzdist(geometry, originVector)
primuv()</p>
<p>expression - opinputpath(name, index) : input에 연결된 노드의 경로 값을 가져옴
opinputpath(".", 0) 현재노드의 0번째(첫번째) 입력</p>
<p>@opinput‹n›_‹name›
@opinput1_P // 입력 1의 P.</p>
<p>v@P = lerp(v@P, @opinput1_P, chf('blend'));</p>
<p>i@id = @ptnum // 현재 point
v@P = lerp(v@P, point(1, 'P', findattribval(1, 'point', 'id', i@id)), chf('blend'));
v@P = lerp(v@P, point(1, 'P', idtopoint(1, i@id)), chf('blend'));</p>
<p>v@pos = uvsample(0, 'P', 'uv', chv('uv'));</p>
<p>setdetailattrib(0, 'foo', @ptnum, 'set');</p>
<p>relpointbbox(2, pos);
addpoint(geoself(), pos);</p>
<p>pointprims   =&gt; point to prim</p>
<p>primpoints   =&gt; prim to point
primvertices</p>
<p>neighbours</p>
<p>pcfind  범위(radius)에서 포인트를 찾음
nearpoints // pcfind를 편히 쓸 수 있는 버전</p>
<p>pritnf/ sprintf</p>
<h2 id="배열"><a class="header" href="#배열">배열</a></h2>
<p>insert / append
removeindex
removevalue
push / pop
resize
len
argsort
reverse
reorder
find</p>
<h2 id="point-cloud"><a class="header" href="#point-cloud">Point Cloud</a></h2>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/vex/functions/pcopen.html">https://www.sidefx.com/docs/houdini/vex/functions/pcopen.html</a></li>
<li>point cloud에서는 원하는 정보만 가져올 수 있다.
<ul>
<li>반면, nearpoint는 포인트만.</li>
</ul>
</li>
</ul>
<pre><code class="language-vex">// pcopen: int  pcopen(int opinput, string Pchannel, vector P, float radius, int maxpoints)

int pc_handle = pcopen(0, "P", @P, 1, 10);

if (pcnumfound(pc_handle) &lt; 3)
{
    removepoint(0, @ptnum);
}

pcclose(pc_handle);
</code></pre>
<pre><code class="language-vex">int pts[] = nearpoints(0, @P, 1, 10);

if (len(pts) &lt; 3)
{
    removepoint(0, @ptnum);
}
</code></pre>
<p>pcimportbyidxf
pcfilter
pciterate
pcfind
pcimport
pcnumfound</p>
<h2 id="제어"><a class="header" href="#제어">제어</a></h2>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/vex/statement.html">https://www.sidefx.com/docs/houdini/vex/statement.html</a></li>
<li>없는거 : switch</li>
</ul>
<p>if / for / while / break / continue / do while</p>
<pre><code class="language-vex">foreach ([element_type] value; array) {

}

foreach (index, value; array) statement;
foreach (int index; element_type value; array) statement;

</code></pre>
<h2 id="함수"><a class="header" href="#함수">함수</a></h2>
<pre><code class="language-vex">
int test(int a; int b; string c)
{
    return 1;
}
</code></pre>
<h2 id="구조체"><a class="header" href="#구조체">구조체</a></h2>
<pre><code>struct SHello
{
    int a = 1;
    int b;

    int Func()
    {
      return a;
    }
}

SHello x = SHello(1, 2);
</code></pre>
<h2 id="문자열"><a class="header" href="#문자열">문자열</a></h2>
<p>startswith
endswith
find
match
concat
join
split
lstrip / rstrip
splitpath
isdigit
opdigits // Returns the integer value of the last sequence of digits of a string https://www.sidefx.com/docs/houdini/vex/functions/opdigits.html
atoi / atof
itoa</p>
<h2 id="정규표현식"><a class="header" href="#정규표현식">정규표현식</a></h2>
<ul>
<li><a href="https://regex101.com">https://regex101.com</a></li>
</ul>
<p>string regex = r'';
i@match = re_match(regex, teststring);
re_match
re_find
re_findall
re_replace
re_split</p>
<h2 id="random"><a class="header" href="#random">Random</a></h2>
<p>https://www.sidefx.com/docs/houdini/vex/random.html</p>
<div class="table-wrapper"><table><thead><tr><th>Noise</th><th>Relative cost</th></tr></thead><tbody>
<tr><td>Perlin noise (noise)</td><td>1.0</td></tr>
<tr><td>Original perlin noise (onoise)</td><td>1.1</td></tr>
<tr><td>Worley noise (wnoise)</td><td>1.8</td></tr>
<tr><td>Sparse Convolution noise (snoise)</td><td>2.1</td></tr>
<tr><td>Alligator noise (anoise)</td><td>2.3</td></tr>
</tbody></table>
</div>
<p>curlnoise
flownoise</p>
<h2 id="수학"><a class="header" href="#수학">수학</a></h2>
<p>fit
lerp
distance</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>normalize</td><td></td></tr>
<tr><td>cross</td><td></td></tr>
<tr><td>abs</td><td></td></tr>
<tr><td>dot</td><td></td></tr>
<tr><td>length</td><td></td></tr>
<tr><td>degree</td><td></td></tr>
<tr><td>min / max</td><td></td></tr>
<tr><td>sin/cos/acos</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>ceil</td><td>올림</td></tr>
<tr><td>floor</td><td>내림</td></tr>
<tr><td>rint</td><td>반올림</td></tr>
<tr><td>trunc</td><td>버림</td></tr>
<tr><td>frac</td><td>소수점 부분만</td></tr>
</tbody></table>
</div>
<h2 id="ref-2"><a class="header" href="#ref-2">Ref</a></h2>
<ul>
<li>
<p>sidefx</p>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/vex/index.html">https://www.sidefx.com/docs/houdini/vex/index.html</a></li>
<li><a href="https://www.sidefx.com/docs/houdini/vex/snippets.html">https://www.sidefx.com/docs/houdini/vex/snippets.html</a></li>
<li><a href="https://www.sidefx.com/learn/vex/">https://www.sidefx.com/learn/vex/</a></li>
<li><a href="https://www.sidefx.com/docs/houdini/ref/expression_cookbook.html">https://www.sidefx.com/docs/houdini/ref/expression_cookbook.html</a></li>
<li><a href="https://www.sidefx.com/docs/houdini/vex/lang.html">https://www.sidefx.com/docs/houdini/vex/lang.html</a></li>
<li><a href="https://www.sidefx.com/docs/houdini/vex/functions/index.html">https://www.sidefx.com/docs/houdini/vex/functions/index.html</a></li>
</ul>
</li>
<li>
<p>tokeru</p>
<ul>
<li><a href="https://www.tokeru.com/cgwiki/?title=HoudiniVex">https://www.tokeru.com/cgwiki/?title=HoudiniVex</a></li>
</ul>
</li>
<li>
<p>jtomori/vex_tutorial</p>
<ul>
<li><a href="https://github.com/jtomori/vex_tutorial">https://github.com/jtomori/vex_tutorial</a></li>
<li><a href="https://jtomori.github.io/vex_tutorial/">https://jtomori.github.io/vex_tutorial/</a></li>
</ul>
</li>
</ul>
<p><a href="https://sites.google.com/site/fujitarium/Houdini/sop/copy-sop">https://sites.google.com/site/fujitarium/Houdini/sop/copy-sop</a></p>
<p>https://www.sidefx.com/docs/houdini/copy/instanceattrs.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python"><a class="header" href="#python">Python</a></h1>
<ul>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/hom/commandline.html#hython">https://www.sidefx.com/docs/houdini/hom/commandline.html#hython</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=PxGTukMnu2U">A Pipeline in Thirteen Lines of Python | Sean Lewkiw | Lost Boys school of VFX | Montreal</a></p>
</li>
<li>
<p>환경변수 확인</p>
<ul>
<li>Help &gt; About Houdini &gt; Show Details</li>
</ul>
</li>
<li>
<p>vscode</p>
<ul>
<li>Edit &gt; Preferences &gt; Set External Text Editor</li>
<li>https://pakreht.com/houdini/configure-vscode-for-python/</li>
<li>https://code.visualstudio.com/docs/python/settings-reference
<ul>
<li>python.pythonPath - 하지만 지금은 Deprecated(더 이상 추천되지 않음) 상태입니다.</li>
<li>python.defaultInterpreterPath **최근(2021년 이후)**에 도입된 설정입니다.</li>
<li>"python.analysis.extraPaths" 비표준 위치에 설치된 패키지에 대해 IntelliSense를 활성화하려면 해당 위치를 파일 python.analysis.extraPaths의 컬렉션 에 추가하세요</li>
<li>python.analysis.stubPath</li>
</ul>
</li>
<li>pylance
<ul>
<li>https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance
<ul>
<li>python.analysis.typeCheckingMode
<ul>
<li>off: No type checking analysis is conducted; unresolved imports/variables diagnostics are produced.</li>
<li>basic: All rules from off + basic type checking rules.</li>
<li>standard: All rules from basic + standard type checking rules.</li>
<li>strict: All rules from standard + strict type checking rules.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>편집: HDA 우클릭 &gt; Edit Extra Sections Source Code &gt; ViewerStateModule &gt; Accept 버튼</p>
</li>
</ul>
<pre><code class="language-python"># New Pane Tab Type &gt; Python Shell
# ref: https://pakreht.com/houdini/configure-vscode-for-python/
# .vscode/setting.json

import sys
import pathlib
import json

pythonexe_path = pathlib.Path(sys.prefix).resolve().joinpath('python.exe')
sys_paths = [pathlib.Path(p).resolve() for p in sys.path]

vscode_settings = {}
vscode_settings["python.defaultInterpreterPath"] = pythonexe_path.as_posix()
vscode_settings["python.analysis.extraPaths"] = [p.as_posix() for p in sys_paths]
vscode_settings["python.analysis.stubPath"] = 'D:/REPLACE/WITH/YOUR/STUB/PATH'

print(json.dumps(vscode_settings, indent=4))
</code></pre>
<pre><code class="language-txt">Windows &gt; Hscript Textport(Alt + Shift + T)

/ -&gt; help otedit
otedit

    REPLACED BY
      - hou.ui.openTypePropertiesDialog()
</code></pre>
<pre><code class="language-txt">## hython path

Linux: /opt/hfs19.0.657/bin/hython
Windows: C:\Program Files\Side Effects Software\Houdini 19.0.657\bin\hython3.7.exe
</code></pre>
<pre><code class="language-json">// setting.json
"python.autoComplete.extraPaths" : [
  "C:/Program Files/Side Effects Software/Houdini 19.0.531/houdini/python3.7libs"
],

"python.autoComplete.preloadModules" : [
  "hou"
],

"python.analysis.extraPaths" : [
  "C:/Program Files/Side Effects Software/Houdini 19.0.531/houdini/python3.7libs"
]
</code></pre>
<ul>
<li>New Shelf...
<ul>
<li>New Tool...
<ul>
<li>Script</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-python">
import hou

obj = hou.node('/obj')
myGeo = obj.createNode('geo', 'myGeo')
box = myGeo.createNode('box', 'myBox')

# print(box.ascode())
 
box.parm('sizex').set(10)

selected = hou.selectedNodes() # tuple
selected[0].setInput(0, selected[1], 0)
</code></pre>
<pre><code class="language-python">
import Pyside2 as ps

</code></pre>
<p>hou.playbar.play()
hou.playbar.stop()</p>
<p>hou.ui.displayMessage("HelloWorld")
hou.ui.displayMessage("HelloWorld", buttons=("OK", "NO"))
hou.ui.readInput("Read Input")</p>
<p>hou.frame()
hou.fps()</p>
<p>hou.selectedNodes()</p>
<p>hou.putenv("ENV_A", "VALUE_A")
hou.unsetenv('A')
hou.getenv("HIP")
hou.hda.reloadAllFiles()</p>
<p>hou.hscript("opparm /obj/geo1 scale 10")</p>
<p>n = hou.node("/obj/geo1")
sphere = n.node("sphere1")</p>
<p>node.parent()
node.children()
node.outputs()
node.inputs()
node.setInput(2, otherNode)
node.setInput(2, None)
node.color()
node.setColor(hou.Color(1, 0, 0))
node.setDisplayFlag(False)
node.isGenericFlagSet(hou.nodeFlag.Display)
node.setGenericFlagSet(hou.nodeFlag.Display, True)
// https://www.sidefx.com/docs/houdini/hom/hou/nodeFlag.html</p>
<p>node.type()
node.createNode('attribwrangle')</p>
<p>node.userDataDict()
node.clearUserDataDict()
node.setUserData('keyString', 'valueString')
node.userData('keyString')
node.destroyUserData('keyString')</p>
<p>https://www.sidefx.com/docs/houdini/hom/hou/OpNode.html#user-data
node.cachedUserDataDict()
node.setCachedUserData('keyString', 'valueString')
node.cachedUserData('keyString')
node.destroyCachedUserData('keyString')</p>
<p>node.asCode()</p>
<p>node.name()
node.setName('test')
node.commnet()
node.setComment('comment')
node.appendComment('append comment')
node.path()
node.position()
node.setPosition((0, 0)) // input : vector
node.move((-1, -1))
node.destroy()
node.evalParm('proj')</p>
<pre><code class="language-txt">// https://www.sidefx.com/docs/houdini/ref/env.html
// https://www.sidefx.com/docs/houdini/hom/locations.html#startup 

HH                    : The path to Houdini supporting scripts and files inside $HFS. Usually $HFS/houdini
HOUDINI_PATH          : The path of directories where Houdini looks for configuration files.
HOUDINI_USER_PREF_DIR : The directory to store user preference files. 

</code></pre>
<p>hou.parm     ("/obj/geo1/tx")
hou.parm     ("/obj/geo1/scale")
hou.parmTuple("/obj/geo1/t")
p = hou.parm     ("/obj/geo1/scale")
p.eval()
p.evalAsString()
p.isTimeDependent()
p.evalAtFrame(10)
p.set(5)
p.name()
p.node()
p.pressButton()
p.keyframes()
p.keyframesAfter(20)
p.deleteAllKeyframes()
p.revertToDefault()
p.expression()
p.expressionLanguage()
p.setExpression('print "Hello"', language=hou.exprLanguage.Python)</p>
<p>node = hou.pwd()
geo = node.geometry()
geo.points()
pt = geo.iterPoints()[0]
pt.prims()
pt.vertices()
geo.attribValue('foo')
geo.setGlobalAttribValue('foo', 5)
pt.attribValue('foo')
pt.setAttribValue('foo', 5)
geo.addAttrib(hou.attribType.Prim, 'myattrib', 0.0, create_local_variable=False)</p>
<p>pts = geo.createPoints([(0, 0, 0)])
geo.deletePoints(pts)</p>
<p>group = geo.findPointGroup('grp1')
group = geo.createPointGroup('grp1')
group.clear()
group.destroy()</p>
<p>p = geo.prim(0)
p.intrinsicValue('typename')</p>
<p>hou.ui.displayMessage("HelloWorld", serverity=hou.serverityType.ImportantMessage, help='help message', detail='detail','title='title')
hou.ui.readMultiInput('wtf', ('1', '2', '3'))
hou.ui.selectFile()
hou.ui.selectFromList(('1', '2', '3'))
hou.ui.selectFromTree(('a/1', 'a/2', '3'))
hou.ui.selectNode()
hou.ui.selectParm()
hou.ui.selectParmTuple()
hou.ui.selectAttrib()
hou.ui.selectColor()
hou.ui.setStatusMessage('hello world')</p>
<p>import hou
n = hou.node('/obj/hello')
t = n.type()
d = t.definition()
group = d.parmTemplateGroup()
group = hou.ParmTemplateGroup()
n.setParmTemplateGroup()
d.setParmTemplateGroup()</p>
<pre><code class="language-python">import hou
n = hou.node('/obj/geo1/transform1')

new_n = n.parent().createNode(n.type().name(), f"{n.name()}_refcopy")
new_n.setPosition(n.position())
new_n.move((0.5, -0.5))
new_n.setColor(hou.color((0.1, 0.1, 0.1)))

group = new_n.parmTemplateGroup()
source = hou.StringParmTemplate('ref_source', 'Reference Source', 1, string_type=hou.stringParmType.NodeRefernece, help='help text')
group.insertBefore((0, ), source)
new_n.setParmTemplateGroup(group)
new_n.parm('ref_source').set(n.path())

temp_list = [
  hou.parm('obj/geo1/transform1_refcopy/scale'),
  hou.parm('obj/geo1/transform1_refcopy/group'),
  hou.parm('obj/geo1/transform1_refcopy/shear')
]
for p in temp_list:
    if p.name() == 'ref_source':
        continue
    if p.parmTemplate().type() == hou.parmTemplateType.Folder:
        continue
    if p.parmTemplate().type() == hou.parmTemplateType.FolderSet:
        continue

    mode = kwargs['ctrlclick']

    if mode:
        expr = 'ch'
        if p.parmTemplate().type() == hou.parmTemplateType.String:
            expr = 'chs'
        p.setExpression(f"{expr}(chs('ref_resource') + '/{p.name()}')")
    else:
        p.setExpression(f"hou.node(hou.pwd().evalParm('ref_source')).evalParm('{p.name()}')", language=exprLangauge.Python)
</code></pre>
<p>PythonModule
def onInputChanged
OnInputChanged
kwargs['node'].hm().onInputChanged(kwargs) # hm - a shortcut for self.hdaModule().</p>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/hom/hou/OpNode.html#hm">https://www.sidefx.com/docs/houdini/hom/hou/OpNode.html#hm</a></li>
</ul>
<p>hou.phm().SomeFunction()                     # hou.phm() == hou.pwd().hdaModule()
https://www.sidefx.com/docs/houdini/hom/hou/phm.html
https://www.sidefx.com/docs/houdini/hom/hou/HDAModule.html</p>
<hr />
<h2 id="hom"><a class="header" href="#hom">HOM</a></h2>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/hom/intro.html">HOM - Houdini Object Model</a>
<ul>
<li>이벤트 <a href="https://www.sidefx.com/docs/houdini/hom/state_events.html">https://www.sidefx.com/docs/houdini/hom/state_events.html</a></li>
<li>컨텍스트 메뉴: <a href="https://www.sidefx.com/docs/houdini/hom/state_menus.html">https://www.sidefx.com/docs/houdini/hom/state_menus.html</a>
<ul>
<li>핫키: <a href="https://www.sidefx.com/docs/houdini/hom/state_menus.html#hotkeys">https://www.sidefx.com/docs/houdini/hom/state_menus.html#hotkeys</a></li>
</ul>
</li>
<li>Drawable: <a href="https://www.sidefx.com/docs/houdini/hom/state_guides.html">https://www.sidefx.com/docs/houdini/hom/state_guides.html</a>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/hom/state_selectors.html">https://www.sidefx.com/docs/houdini/hom/state_selectors.html</a></li>
</ul>
</li>
<li>핸들: <a href="https://www.sidefx.com/docs/houdini/hom/state_handles.html">https://www.sidefx.com/docs/houdini/hom/state_handles.html</a></li>
<li>파라미터: <a href="https://www.sidefx.com/docs/houdini/hom/state_parameters.html">https://www.sidefx.com/docs/houdini/hom/state_parameters.html</a></li>
<li>HUD: <a href="https://www.sidefx.com/docs/houdini/hom/hud_info.html">https://www.sidefx.com/docs/houdini/hom/hud_info.html</a>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/hom/hou/SceneViewer.html#hudInfo">https://www.sidefx.com/docs/houdini/hom/hou/SceneViewer.html#hudInfo</a></li>
<li>QT: <a href="https://www.sidefx.com/docs/houdini/hom/cb/qt.html">https://www.sidefx.com/docs/houdini/hom/cb/qt.html</a>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/hom/hou/qt/index.html">https://www.sidefx.com/docs/houdini/hom/hou/qt/index.html</a></li>
</ul>
</li>
</ul>
</li>
<li>Drag &amp; Drop: <a href="https://www.sidefx.com/docs/houdini/hom/state_dragdrop.html">https://www.sidefx.com/docs/houdini/hom/state_dragdrop.html</a></li>
<li>Undo : <a href="https://www.sidefx.com/docs/houdini/hom/state_undo.html">https://www.sidefx.com/docs/houdini/hom/state_undo.html</a></li>
</ul>
</li>
</ul>
<p>Tool scripts
https://www.sidefx.com/docs/houdini/hom/tool_script.html</p>
<h3 id="x"><a class="header" href="#x">x</a></h3>
<ul>
<li><a href="https://www.sidefx.com/tutorials/houdini-cable-tool-with-python-viewer-states/">https://www.sidefx.com/tutorials/houdini-cable-tool-with-python-viewer-states/</a></li>
<li><a href="https://www.sidefx.com/docs/houdini/hom/python_states.html">Writing custom viewer states in Python</a></li>
<li>상태등록
<ul>
<li>Houdini는 시작 시 createViewerStateTemplate상태 템플릿에 접근하여 등록을 수행합니다.</li>
<li>viewerstate.utilsHoudini는 뷰어 상태 설치를 지원하고 사용자가 직접 상태를 구현할 수 있도록 다양한 문서화된 유틸리티 함수와 클래스를 포함하는 Python 모듈을 제공합니다.</li>
<li>이 모듈은 $HHP/viewerstate폴더 아래에 있습니다.</li>
</ul>
</li>
</ul>
<pre><code class="language-python">class MyState(object):
  # 생성자는 필수
  def __init__(self, state_name, scene_viewer):
        self.state_name = state_name
        self.scene_viewer = scene_viewer

# Event Handler
#
## Life Cycle
#
# onEnter
# onInterrupt
# onExit
# onResume
# onGenerate
# 
## UI
#
# onMouseEvent
# onMouseDoubleClickEvent
# onMouseWheelEvent
# 
# onKeyEvent
# onKeyTransitEvent
# 
# onMenuAction
# onMenuPreOpen
# 
# onParmChangeEvent
# onPlaybackChangeEvent
# onCommand
# 
## Handle
#
# onHandleToState
# onStateToHandle
# onBeginHandleToState
# onEndHandleToState
# 
## Selection
#
# onStartSelection
# onSelection
# onStopSelection
# onLocateSelection
#
## Drawing
# 
# onDraw
# onDrawInterrupt
#
## Drag &amp; Drop
# 
# onDragTest
# onDropGetOptions
# onDropAccept
#

def createViewerStateTemplate():
    state_typename = kwargs["type"].definition().sections()["DefaultState"].contents() # Edit Operator Type Properties &gt; Node &gt; Default State
    state_label = "Label"
    state_cat = hou.sopNodeTypeCategory()

    template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
    template.bindFactory(MyState)
    template.bindIcon(kwargs["type"].icon())

    return template

</code></pre>
<hr />
<ul>
<li>스크립팅 : Edit Operator Type Properties &gt; Interactive &gt; State Script &gt; New...</li>
<li>디버그창 : New Pane Tab Type &gt; Inspectors &gt; Viewer State Browser</li>
<li>디버그
<ul>
<li>scene_viewer.setPromptMessage # 말 그대로 씬 뷰어 <a href="https://www.sidefx.com/docs/houdini/hom/hou/SceneViewer.html">https://www.sidefx.com/docs/houdini/hom/hou/SceneViewer.html</a></li>
<li>self.log # =&gt; Viewer State Browser</li>
<li>print()  # =&gt; 메시지창</li>
</ul>
</li>
</ul>
<p>ui_event = kwargs["ui_event"]
https://www.sidefx.com/docs/houdini/hom/hou/UIEvent.html
ui_event = kwargs["ui_event"]
reason = ui_event.reason() # https://www.sidefx.com/docs/houdini/hom/hou/uiEventReason.html
dev = ui_event.device()    # https://www.sidefx.com/docs/houdini/hom/hou/UIEventDevice.html
self.log("Mouse:", dev.mouseX(), dev.mouseY(), dev.isLeftButton())</p>
<p>geometry = self._node.geometry(0)
https://www.sidefx.com/docs/houdini/hom/hou/Geometry.html
intersected = geometry.intersect(origin, direction, position, normal, uvw)</p>
<p>state_parms = kwargs["state_parms"]
바인딩된 파라미터
https://www.sidefx.com/docs/houdini/hom/state_parameters.html#binding-the-parameter</p>
<hr />
<p>패키지 파일을 이용한 환경 변수 설정</p>
<p>$HOUDINI_USER_PREF_DIR/packages/PythonStateCourse.json를 사용하여 PYSTATECOURSE 환경변수 정의</p>
<pre><code class="language-json">// https://www.sidefx.com/docs/houdini/ref/plugins.html
{
	"path": "$PYSTATECOURSE",
	"load_package_once": true,
	"env": [
		{
			"PYSTATECOURSE": "C:/Users/pyoung/Downloads/GumroadPythonStatesforHoudiniTDs/course"
		}
	]
}
</code></pre>
<p>PYSTATECOURSE환경 변수에 정의된 경로를 이용하여 viewer_states 등록
C:/Users/pyoung/Downloads/GumroadPythonStatesforHoudiniTDs/course/viewer_states/nodelsss_state_example.py - viewer_states폴더 (이름 주의)</p>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/hom/python_states.html">Writing custom viewer states in Python</a></li>
</ul>
<pre><code class="language-python">import hou
import viewerstate.utils as su

class State(object):
    def __init__(self, state_name, scene_viewer):
        self.state_name = state_name
        self.scene_viewer = scene_viewer


def createViewerStateTemplate():
    """ Mandatory entry point to create and return the viewer state 
        template to register. """

    state_typename = "course::nodeless_state_example::1.0"
    state_label = "1 Course - Nodeless State Example"
    state_cat = hou.objNodeTypeCategory()

    template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
    template.bindFactory(State)
    template.bindIcon("MISC_python")
    return template
</code></pre>
<ul>
<li>디버그창 : New Pane Tab Type &gt; Inspectors &gt; Viewer State Browser
<ul>
<li>1 Course - Nodeless State Example 우클릭 Enter버튼</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>
<p>툴바</p>
<ul>
<li>파라미터에서 Show Parm In &gt; Main &amp; Tool Dialogs + ToolBox로 노출 가능</li>
<li>아니면 python코드에서 template.bindParameter(...) 사용해서 노출가능</li>
</ul>
</li>
<li>
<p>Python은 Compile Block에서 사용할 수 없어 Invoke노드에서 호출이 안됨</p>
<ul>
<li>Network View Display Options &gt; Context Specific Badge &gt; Non-compilable SOP Badge &gt; Normal (기본값 Hide)</li>
<li>Invoke Compiled Block
<ul>
<li>Compile Block: 여기는 Compile Block의 End부분이 들어가야함</li>
<li>Input Name: 여기는 Compile Block의 Begin부분에서 Input Name과 맞춰주면 됨</li>
</ul>
</li>
<li>Compile Block
<ul>
<li>Input Name:</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="도로의-크기회전-조절"><a class="header" href="#도로의-크기회전-조절">도로의 크기&amp;회전 조절</a></h2>
<ul>
<li><a href="https://jeroen.denayer.com/">https://jeroen.denayer.com/</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=2XIIEhgcWMQ">Houdini: Python Viewer State - Interactive curve point rotation and scaling - Tutorial</a></li>
<li><a href="https://www.youtube.com/watch?v=mBdKK_VKDHQ&amp;t=893s">BUas Procedural Showcase | Aleksandra Radivilovic, Erwin Smeenge, Jens van Kampen, Joshua Rizzo ...</a></li>
<li><a href="https://pepri.gumroad.com/l/UHmyL">https://pepri.gumroad.com/l/UHmyL</a></li>
</ul>
</li>
</ul>
<pre><code class="language-txt">Edit Operator Type Properties &gt; Parameters

- p_shift Integer 
- p_json  String
- p_reset Button
</code></pre>
<pre><code class="language-python"># 버튼 &gt; Callback script
# hou.pwd().hm().reset(kwargs)

# Edit Operator Type Properties &gt; Scripts - Event Handler가 Python Module인거 확인
import json

def reset(kwargs):
    node = kwargs["node"]

    npoints = 0
    geo = node.geometry()
    if geo:
        npoints = geo.attribValue("handles")
    
    json_list = [{"banking": 0, "scale": 0} for _ in range(npoints)]
    json_parm = node.parm("p_json")
    json_parm.set(json.dumps(json_list))
</code></pre>
<pre><code class="language-python"># Edit Operator Type Properties &gt; Interactive &gt; State Script &gt; New...
import hou
import json
from typing import TypedDict

class Item(TypedDict):
    scale: float
    banking: float

class Util:
    @staticmethod
    def clamp(x: int, min_val: int, max_val: int) -&gt; int:
        return max(min_val, min(x, max_val))

class State(object):
    
    MSG = "Click and drag to rotate, hold shift to scale"

    def __init__(self, state_name, scene_viewer):
        self._state_name = state_name
        self._scene_viewer = scene_viewer

        self._node = None
        self._p_shift: int = 0
        self._p_json: str = ''

        self._json_list: list[Item] = [] # [{"banking": 0, "scale": 0}, ...]
        self._selected_pt_num: int = -1
        self._mouse_x_start: int = 0
        self._offset_sign: int = 1

    def onEnter(self, kwargs):
        self._node = kwargs["node"]
        self._p_shift = self._node.parm("p_shift") # hda 파라미터 이름
        self._p_json = self._node.parm("p_json")   # hda 파라미터 이름
        
        self._scene_viewer.setPromptMessage(State.MSG)
 
        geo = self._node.geometry(0)
        npoints = 0
        if geo:
            npoints = geo.attribValue("handles")
            
        json_str = self._p_json.eval()
        if not json_str:
            self._json_list = self._resize([], npoints)
            return
        
        loaded = json.loads(json_str)
        self._json_list = self._resize(loaded, npoints)

    def _resize(self, lst: list, cnt: int) -&gt; list:
        diff: int = len(lst) - cnt
        if diff &lt; 0:
            return lst + [Item(scale= 1, banking= 0) for _ in range(abs(diff))]
        elif diff &gt; 0:
            return lst[:cnt]
        else:
            return lst

    def onMouseEvent(self, kwargs):
        ui_event = kwargs["ui_event"]

        reason = ui_event.reason()
        dev = ui_event.device()
        # self.log("Mouse:", dev.mouseX(), dev.mouseY(), dev.isLeftButton())
        
        if reason == hou.uiEventReason.Start:
            self._mouse_x_start = dev.mouseX()
        
            geo = self._node.geometry(0)
            origin, direction = ui_event.ray()
            position = hou.Vector3()
            normal = hou.Vector3()
            uvw = hou.Vector3()
            intersected = geo.intersect(origin, direction, position, normal, uvw)
            
            if intersected == -1:
                self._selected_pt_num = -1
                return False
            
            prim = geo.prim(intersected)
            self._selected_pt_num = prim.attribValue("pt_num")
            normal = prim.floatListAttribValue("direction")
            normal = hou.Vector3(normal)
            angle = direction.angleTo(normal)
            if angle &lt; 90:
                self._offset_sign = 1
            else:
                self._offset_sign = -1
            return False

        if reason == hou.uiEventReason.Active:
            if self._selected_pt_num == -1:
                return False
            
            x_offset = dev.mouseX() - self._mouse_x_start
            self._mouse_x_start = dev.mouseX()
            pt_dict: Item = self._json_list[self._selected_pt_num]
                
            if self._is_shift():
                next_scale = pt_dict["scale"] + x_offset
                pt_dict["scale"] = Util.clamp(next_scale, -800, 5000)
            else:
                next_banking = pt_dict["banking"] + (self._offset_sign * x_offset)
                pt_dict["banking"] = next_banking
            # self._json_list[self._selected_pt_num] = pt_dict
            json_str = json.dumps(self._json_list)
            self._p_json.set(json_str)

        # Must return True to consume the event
        return False

    def onKeyTransitEvent(self, kwargs):
        ui_event = kwargs["ui_event"]

        if ui_event.device().isShiftKey():
            self._p_shift.set(1)
        else:
            self._p_shift.set(0)
        # Must returns True to consume the event
        return False

    def _is_shift(self) -&gt; bool:
        return self._p_shift.evalAsInt() == 1


def createViewerStateTemplate():
    state_typename = kwargs["type"].definition().sections()["DefaultState"].contents()
    state_label = "P3tpr subnet1"
    state_cat = hou.sopNodeTypeCategory()

    template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
    template.bindFactory(State)
    template.bindIcon(kwargs["type"].icon())

    return template

## dataclass도 고려해봤지만, 이건 내장 json로더가 손이 간다.
## Interactive쪽에만 코드를 짜면 dataclass를 어찌 집어넣을 수 있겠지만, python노드에서 로더부분을 건드리면 비용이 배가 될것이다.
## import dataclasses
## 
## class JSON(json.JSONEncoder):
##     def default(self, o):
##         if dataclasses.is_dataclass(o):
##             return dataclasses.asdict(o)
##         return super().default(o)
##     
##     @staticmethod
##     def to_str(o: object) -&gt; str:
##         return json.dumps(o, cls=JSON)
## 
## @dataclasses.dataclass
## class Item:
##     scale: float
##     banking: float
## 
## def load_items(json_str: str) -&gt; list[Item]:
##     data = json.loads(json_str)
##     return [Item(**item) for item in data]
</code></pre>
<p>노드</p>
<p><img src="script/./res/road.png" alt="" /></p>
<ul>
<li>detail wrangle
<ul>
<li>i@handles = npoints(0);</li>
</ul>
</li>
<li>Point Wrangle
<ul>
<li>f@pscale = 1;</li>
<li>@prot = 0;</li>
</ul>
</li>
<li>python</li>
</ul>
<pre><code class="language-python"># 커브 인풋에서 Python 노드 추가
#  - Edit Parameter Interface - json_in String 넣기
# 추가한 json_in텍스트에 `chs("../p_json")` 넣기
#  - 그러면 hou.evalParm("./json_in") 로 불러오기 가능
#  - 아니면 곧 바로 hou.evalParm("../p_json")

import json

node = hou.pwd()
geo = node.geometry()

json_str = hou.evalParm("./json_in")
json_list = []
if json_str:
    json_list = json.loads(json_str)

for point in geo.points():
    pt_num = point.number()
    try:
        pt_dict = json_list[pt_num]
    except:
        break
    
    pscale = pt_dict["scale"]
    pscale = (pscale + 1000) / 1000    
    prot = pt_dict["banking"] / 1000
    
    point.setAttribValue("pscale", float(pscale))
    point.setAttribValue("prot", float(prot))
</code></pre>
<ul>
<li>Poly Frame
<ul>
<li>Tangent : N</li>
</ul>
</li>
<li>point wrangle
<pre><code class="language-vex">vector up = set(0,1,0);
float angle = f@prot;
matrix rot = ident();
vector axis = @N;
rotate(rot, angle , normalize(axis));
vector rotateP = up * rot;
@up = rotateP;
</code></pre>
</li>
</ul>
<p>여기까지가 BASE_LINE</p>
<ul>
<li>point Wrangle
<pre><code class="language-vex">i@pt_num = @ptnum;
v@direction = @N;
</code></pre>
</li>
<li>Copy To Point</li>
<li>Attribute Promote
<ul>
<li>pt_num, direction:point =&gt; primitive</li>
</ul>
</li>
</ul>
<h3 id="todo-jeroen-denayer는-여기서-한발-더-나갔다"><a class="header" href="#todo-jeroen-denayer는-여기서-한발-더-나갔다">:TODO Jeroen Denayer는 여기서 한발 더 나갔다</a></h3>
<pre><code class="language-txt">- scale
- scale_left
- scale_right
- bank


activeHandle
activeHandleParms_hide
  curve_pos
  handle_type
  basic/
    basic__rotation
    basic_road_width
    basic_road_width_hide
  delete/
    delete__length
  rail/
    rail__length


def getAllHandleTypeParms():
    main_floder = ptg.find("f_activeHandleParms")
    pts = main_floder.parmTemplates()

    parms = []
    for pt in pts:
    if pt.type() != hou.parmTemplateType.Folder:
        parms.append(pt.name())
    else:
        pt_folder = pt
        for pt in pt_folder.parmTemplates():
            if "_hide" not in pt.name():
                parms.append(pt.name())
                
    return parms
    
parms = getAllHandleTypeParms()
node.parm("allHandParms").set(json.dumps(parms))

###

def updateActiveHandleParm(kwargs):
    node = kwargs["node"]
    phm = node.hdaModule()
    jsp = node.parm("allHandlesJson")
    jsl = json.loads(jsp.eval())
    index = kwargs["script_value"]
    handle_dict = jsl[index]

###
for parm_name in handle_dict:
    value = handle_dict[parm_name]
    node.parm(parm_name).set(value)
    visible_parms.append(parm_name)

###

def updateActiveHandleParm(kwargs, re_draw_ui = False):
    # Update the json when an active handle parameter changes value.

    node, parm_name = kwargs['node'], kwargs['parm_name']
    phm = node.hdaModule()
    jsp, jsl, ahps, ah = phm.getParmsAndValues(node)
    
    value = node.parm(parm_name).eval()
    jsl[ah][name] = value
    jsp.set(json.dumps(jsl))

###
</code></pre>
<h2 id="레고-블록-쌓기"><a class="header" href="#레고-블록-쌓기">레고 블록 쌓기</a></h2>
<p>상태</p>
<pre><code class="language-python"># ref - [Python States | Paul Ambrosiussen | Games Workshop](https://www.youtube.com/watch?v=H2_38R-V9Gw)
# - blocks      Multiparam Block(list)
#   - pos_#     float3
#   - rot_#     int
#   - hue_#     float
#   - variant_# int

# self._gi = su.GeometryIntersector(hou.Geometry(), scene_viewer=self.scene_viewer)
# self._gi.geometry = self._collision_node.geometry().freeze()
# ui_event = kwargs["ui_event"]
# origin, direction = ui_event.ray()
# self._gi.intersect(origin, direction)

import hou
import viewerstate.utils as su

class State(object):
    def __init__(self, state_name, scene_viewer):
        self.state_name = state_name
        self.scene_viewer = scene_viewer

        self._node = None           # onEnter에서 할당. hda노드
        self._collision_node = None # onEnter에서 할당. BLOCK_COLLISION는 요철(Stud) 부분이 없는 NULL노드
        self._active_block_type = 0 # 0은 4x2블럭, 1은 2x2블럭
        self._active_hue = 0
        self._active_rot = 0
        self._gi = su.GeometryIntersector(hou.Geometry(), scene_viewer=self.scene_viewer)

    def onEnter(self,kwargs):
        self._node = kwargs["node"]
        self._collision_node = self._node.node("BLOCK_COLLISION") # BLOCK_COLLISION는 요철(Stud) 부분이 없는 NULL노드
        self.UpdateCollisionGeo()

        if self.GetMultiParmEntries() == 0:
            self.AddMultiParmEntry()

    ######################
    def GetMultiParmEntries(self) -&gt; int:
        return self._node.parm("blocks").evalAsInt()

    def AddMultiParmEntry(self):
        next_multiparm_entry = self.GetMultiParmEntries() + 1
        self._node.parm("blocks").set(next_multiparm_entry)
        self._node.parm(f"variant_{next_multiparm_entry}").set(self._active_block_type)
        self._node.parm(f"hue_{next_multiparm_entry}").set(self._active_hue)
        self._node.parm(f"rot_{next_multiparm_entry}").set(self._active_rot)

    def UpdateCollisionGeo(self):
        self._gi.geometry = self._collision_node.geometry().freeze()
    ######################

    def onMouseEvent(self, kwargs):
        ui_event = kwargs["ui_event"]
        origin, direction = ui_event.ray()
        self._gi.intersect(origin, direction)
        if self._gi.prim_num == -1:
            return False

        # 클릭한 순간 추가
        if ui_event.reason() == hou.uiEventReason.Picked:
            if ui_event.device().isLeftButton():
                self.AddMultiParmEntry()
                self.UpdateCollisionGeo()

        # 마우스 건드리면 항상 미리보기 위치 변경
        multiparm_entry = self.GetMultiParmEntries()
        intersected_position = hou.Vector3(round(self._gi.position.x()), round(self._gi.position.y()), round(self._gi.position.z()))
        self._node.parmTuple(f"pos_{multiparm_entry}").set(intersected_position)
        
        # Must return True to consume the event
        return True

    def onMouseWheelEvent(self, kwargs):
        # 휠 돌리면 Shift  누르면 HUE 변경
        # 휠 돌리면 Shift안누르면 90도 회전

        ui_event = kwargs["ui_event"]
        state_parms = kwargs["state_parms"]

        device = ui_event.device()
        scroll = device.mouseWheel()
        multiparm_entry = self.GetMultiParmEntries()
        if device.isShiftKey():
            new_value = self._node.parm(f"hue_{multiparm_entry}").evalAsFloat() + scroll / 100
            self._node.parm(f"hue_{multiparm_entry}").set(new_value)
            self._active_hue = new_value
        else:
            new_value = self._node.parm(f"rot_{multiparm_entry}").evalAsInt() + int(scroll * 90)
            self._node.parm(f"rot_{multiparm_entry}").set(new_value)
            self._active_rot = new_value
        # Must return True to consume the event
        return False

    def onMenuAction(self, kwargs):
        # 아레 context menu에서 넘어옴
        menu_item = kwargs["menu_item"]

        if menu_item == 'blocktype':
            active_block_type = int(kwargs["blocktype"])
            multiparm_entry = self.GetMultiParmEntries()
            self._node.parm(f"variant_{multiparm_entry}").set(active_block_type)
            self._active_block_type = active_block_type


def createViewerStateTemplate():
    state_typename = kwargs["type"].definition().sections()["DefaultState"].contents()
    state_label = "9 Course - Block Placer"
    state_cat = hou.sopNodeTypeCategory()

    template = hou.ViewerStateTemplate(state_typename, state_label, state_cat)
    template.bindFactory(State)
    template.bindIcon(kwargs["type"].icon())

    # 우클릭 context menu 정의
    # https://www.sidefx.com/docs/houdini/hom/hou/ViewerStateMenu.html
    context_menu = hou.ViewerStateMenu('menu', 'Example')
    context_menu.addRadioStrip("blocktype", "Block Type", "0")
    context_menu.addRadioStripItem("blocktype", "0", "8 Pin")
    context_menu.addRadioStripItem("blocktype", "1", "4 Pin")
    template.bindMenu(context_menu)
    return template
</code></pre>
<ul>
<li>Point Generate
<ul>
<li>blocks 수 만큼</li>
</ul>
</li>
<li>Point Wrangle
<pre><code class="language-vex">string iteration = itoa(@ptnum + 1);

vector pos = chv("../pos_" + iteration);
float rot = radians(chi("../rot_" + iteration));
float hue = chf("../hue_" + iteration);
int variant = chi("../variant_" + iteration);

v@P = pos;
p@rot = eulertoquaternion(set(0, rot, 0), XFORM_XYZ);
v@Cd = hsvtorgb(hue, 1, 1);
i@variant = variant;
</code></pre>
</li>
<li>Copy To Point
<ul>
<li>Piece Attribute: variant</li>
</ul>
</li>
<li>Grid랑 머지하고 아웃풋</li>
</ul>
<p>BLOCK_COLLISION은</p>
<ul>
<li>Blast
<ul>
<li>Group: knobs 를 날려주고</li>
</ul>
</li>
<li>Attr Delete / Group Delete로 깔끔하게 해주자</li>
<li>그 다음 Null노드로 이름 BLOCK_COLLISION</li>
</ul>
<h2 id="qt"><a class="header" href="#qt">Qt</a></h2>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/hom/cb/qt.html">https://www.sidefx.com/docs/houdini/hom/cb/qt.html</a>
<ul>
<li>PySide2가 후디니에 내장되어있다. - PySide6로 업글예정</li>
<li><a href="https://www.sidefx.com/docs/houdini/ref/panes/pythonpanel.html">https://www.sidefx.com/docs/houdini/ref/panes/pythonpanel.html</a></li>
</ul>
</li>
<li><a href="https://doc.qt.io/qtforpython-6/">https://doc.qt.io/qtforpython-6/</a></li>
<li><a href="https://wikidocs.net/book/2957">공학자를 위한 PySide2</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hscript-expressions"><a class="header" href="#hscript-expressions">HScript expressions</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>$N</td><td>'npoints(0)-1</td></tr>
</tbody></table>
</div>
<p>$HIP
$JOB
$HIPNAME
$HH</p>
<p>$F
$SF
$FF
$FPS
$T</p>
<h2 id="expression"><a class="header" href="#expression">Expression</a></h2>
<pre><code class="language-vex">$BBX = relbbox(@P).x
$BBY = relbbox(@P).y
$BBZ = relbbox(@P).z
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Expression Local Variables</th><th></th></tr></thead><tbody>
<tr><td>$PT</td><td>포인트 번호</td></tr>
<tr><td>$PR</td><td>프리미티브 번호</td></tr>
<tr><td>$CY</td><td>현재 사본 번호</td></tr>
<tr><td>$TX   , $TY   , $TZ</td><td>트랜스폼</td></tr>
<tr><td>$TX2  , $TY2  , $TZ2</td><td>두번째 입력에서 오는 포인트 위치</td></tr>
<tr><td>$NX   , $NY   , $NZ</td><td>노말</td></tr>
<tr><td>$CR   , $CG   , $CB   , $CA</td><td>칼라</td></tr>
<tr><td>$VX   , $VY   , $VZ</td><td>벨로시티</td></tr>
<tr><td>$BBX  , $BBY  , $BBZ</td><td>바운딩 박스 내 점 위치（0 ~ 1）</td></tr>
<tr><td>$CEX  , $CEY  , $CEZ</td><td>기하학의 중심</td></tr>
<tr><td>$AGE</td><td>파티클 수명(초)</td></tr>
<tr><td>$LIFE</td><td>파티클 수명(0 ~ 1)</td></tr>
<tr><td>$XMIN , $XMAX , $YMIN  , $YMAX,$ZMIN,$ZMAX</td><td>경계 범위</td></tr>
<tr><td>$SIZEX, $SIZEY, $SIZEZ</td><td>경계 크기</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>box 바닦붙이기</p>
<ul>
<li>box의 translate.y = $SIZEY/2</li>
<li>혹은 center.y = ch("sizey")/2</li>
</ul>
</li>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/ref/expression_cookbook.html">https://www.sidefx.com/docs/houdini/ref/expression_cookbook.html</a></p>
</li>
<li>
<p>detail</p>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/expressions/detail.html">https://www.sidefx.com/docs/houdini/expressions/detail.html</a></li>
</ul>
</li>
<li>
<p>opinputpath</p>
</li>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/expressions/opinputpath.html">https://www.sidefx.com/docs/houdini/expressions/opinputpath.html</a></p>
</li>
</ul>
<p>padzero</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opencl"><a class="header" href="#opencl">OpenCL</a></h1>
<ul>
<li>OpenCL CPU/GPU 변경
<ul>
<li>Edit &gt; Preferences &gt; Miscellaneous
<ul>
<li>OpenGL Device
<ul>
<li>Type : CPU/GPU</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glsl"><a class="header" href="#glsl">GLSL</a></h1>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/shade/glsl.html">https://www.sidefx.com/docs/houdini/shade/glsl.html</a></li>
</ul>
<h2 id="커스텀-glsl"><a class="header" href="#커스텀-glsl">커스텀 GLSL</a></h2>
<ul>
<li>
<p>File &gt; New Assets...</p>
<ul>
<li>Definition : VOPs</li>
<li>Network Type : GLSL Shader</li>
<li>Code 탭에서 셰이더 작성</li>
</ul>
</li>
<li>
<p>Material Network</p>
<ul>
<li>생성된 노드 추가</li>
</ul>
</li>
<li>
<p>Sphere - UV Unwrap - Material</p>
<ul>
<li>Material: 에 Material Network에 추가된 것 추가</li>
</ul>
</li>
</ul>
<h2 id="shop--deprecated-"><a class="header" href="#shop--deprecated-">SHOP ( Deprecated )</a></h2>
<ul>
<li>SHOP Network
<ul>
<li>Material Shader Builder
<ul>
<li>Inline Code</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<p>.vert: vertex shader
.frag: fragment shader
.geom: geometry shader
.tcs: tessellation control shader (GL4.0+)
.tes: tessellation evaluation shader (GL4.0+)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vat"><a class="header" href="#vat">VAT</a></h1>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>VAT</td><td>Vertex Animation Texture</td></tr>
<tr><td>ROP</td><td>Render OPerator(for a Houdini )</td></tr>
</tbody></table>
</div>
<p>C:/Program Files/Side Effects Software/sidefx_packages/SideFXLabs19.5/otls/SideFX_Labs.hda</p>
<div class="table-wrapper"><table><thead><tr><th>unity .meta</th><th>guid</th></tr></thead><tbody>
<tr><td>VAT_RigidBodyDynamics.shadergraph.meta</td><td>085ef3ec3a5a70d4790c0957d30c9f63</td></tr>
<tr><td>VAT_ParticleSprites.shadergraph.meta</td><td>8bf13a6837d559049924774e12033384</td></tr>
<tr><td>VAT_DynamicRemeshing.shadergraph.meta</td><td>19b419010e1004644affea18d0fc8dff</td></tr>
<tr><td>VAT_SoftBodyDeformation.shadergraph.meta</td><td>987a09a96b5f17d46a88a7c429d130d2</td></tr>
</tbody></table>
</div>
<pre><code class="language-txt">// SideFX_Labs.hda

parm {
    name    "mat_unity_soft"
    label   "Unity Soft Material"
    type    string
    invisible
    default {}
}
parm {
    name    "mat_unity_rigid"
    label   "Unity Rigid Material"
    type    string
    invisible
    default { }
}
parm {
    name    "mat_unity_fluid"
    label   "Unity Fluid Material"
    type    string
    invisible
    default { }
}
parm {
    name    "mat_unity_sprite"
    label   "Unity Sprite Material"
    type    string
    invisible
    default { }
}
</code></pre>
<pre><code class="language-json">// https://github.com/sideeffects/SideFXLabs/blob/Development/unity/shaders/URP_VAT3/package.json

"com.sidefx.vat": "https://github.com/sideeffects/SideFXLabs.git?path=unity/shaders/URP_VAT3#Development"
</code></pre>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th>그대로</th><th>변함</th><th>ex</th></tr></thead><tbody>
<tr><td>Soft</td><td>Constant Topology</td><td>정점 갯수</td><td>위치</td><td>캐릭터 애니메이션</td></tr>
<tr><td>Rigid</td><td>Rigid Body Topology</td><td>메쉬 형태</td><td>메쉬 위치</td><td>파괴</td></tr>
<tr><td>Fluid</td><td>Changing Topology</td><td></td><td>정점 위치, 정점 갯수</td><td>유체</td></tr>
<tr><td>Sprite</td><td>Camera Facing Cards</td><td></td><td></td><td>파티클</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>[Project]/meshes/[Component]_mesh.fbx</td><td>mesh</td></tr>
<tr><td>[Project]/textures/[Component]_pos.exr</td><td>position</td></tr>
<tr><td>[Project]/textures/[Component]_norm.exr</td><td>normal</td></tr>
<tr><td>[Project]/textures/[Component]_rot.exr</td><td>rotation</td></tr>
<tr><td>[Project]/textures/[Component]_col.exr</td><td>color</td></tr>
<tr><td>[Project]/materials/[Component]_data.json</td><td></td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Mesh Settings</th><th>Turn every toggle off.</th></tr></thead><tbody>
<tr><td>Preserve Hierarchy</td><td>On</td></tr>
<tr><td>Sort Hierarchy By Name</td><td>On</td></tr>
<tr><td>Mesh Compression</td><td>Off</td></tr>
<tr><td>Optimize Mesh</td><td>Nothing</td></tr>
<tr><td>Index Format</td><td>Auto</td></tr>
<tr><td>Normals</td><td>Import</td></tr>
<tr><td>Normals Mode</td><td>Area And Angle Weighted</td></tr>
<tr><td>Smoothness Source</td><td>Prefer Smoothing Groups (or whatever you prefer)</td></tr>
<tr><td>Smoothing Angle</td><td>60 (or whatever you prefer)</td></tr>
<tr><td>Tangents</td><td>Import</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Texture Settings</th><th>Turn every toggle off.</th></tr></thead><tbody>
<tr><td>Texture Type</td><td>Default.</td></tr>
<tr><td>Texture Shape</td><td>2D.</td></tr>
<tr><td>Alpha Source</td><td>Input Texture Alpha.</td></tr>
<tr><td>Non-Power of 2</td><td>None.</td></tr>
<tr><td>Wrap Mode</td><td>Repeat.</td></tr>
<tr><td>Filter Mode</td><td>Point (no filter).</td></tr>
</tbody></table>
</div><div class="table-wrapper"><table><thead><tr><th>Override</th><th>For Windows, Mac, Linux: On.</th></tr></thead><tbody>
<tr><td>Max Size</td><td>8192</td></tr>
<tr><td>Resize Algorithm</td><td>Mitchell.</td></tr>
<tr><td>Format</td><td>RGBA Half (16 bit per channel; HDR or even Non-HDR)</td></tr>
<tr><td></td><td>RGBA 32 bit (8 bit per channel; Non-HDR).</td></tr>
</tbody></table>
</div>
<h2 id="rigidbody"><a class="header" href="#rigidbody">Rigidbody</a></h2>
<pre><code class="language-node">Geo
    Sphere
    RBD Material Fracture
    UV Unwrap
    Assemble
    RBD Bullet Solver
    - Transfer Attributes: orient pivot P
    - Transfer to Geometry: checked ???
    - Transfer to Proxy Geometry: unchecked ???

Out
Mode/Target Engine: Rigid-Body Dynamics(Rigid) / Unity
Settings
    Edge Case Handling
        Input Geometry Is Cached to Integer Frames: checked
        Texture Format: HDR(EXR/TIFF as RGBA 16/32 in Engine)
</code></pre>
<h2 id="ref-3"><a class="header" href="#ref-3">REF</a></h2>
<ul>
<li><a href="https://qiita.com/yasuhiro0122/items/1222b61549891af6c2f4">https://qiita.com/yasuhiro0122/items/1222b61549891af6c2f4</a></li>
<li><a href="https://medium.com/tech-at-wildlife-studios/texture-animation-techniques-1daecb316657">https://medium.com/tech-at-wildlife-studios/texture-animation-techniques-1daecb316657</a></li>
<li><a href="https://www.sidefx.com/tutorials/vertex-animation-textures-in-unity/">https://www.sidefx.com/tutorials/vertex-animation-textures-in-unity/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>랜드스케이프</p>
<ul>
<li>
<p>HoudiniXUE4 활용하여 랜드스케이프에 어셋 배치하기</p>
<ul>
<li><a href="https://blog.naver.com/sjm931120/222491883124">#1</a></li>
<li><a href="https://blog.naver.com/sjm931120/222493058735">#2</a></li>
<li><a href="https://blog.naver.com/sjm931120/222497294084">#3</a></li>
<li><a href="https://blog.naver.com/sjm931120/222498616900">#4</a></li>
<li><a href="https://blog.naver.com/sjm931120/222518960045">#5</a></li>
<li><a href="https://blog.naver.com/sjm931120/222521294772">#6</a></li>
</ul>
</li>
<li>
<p>에픽 라이브 | 언리얼 엔진 이펙트에 후디니 활용하기</p>
<ul>
<li><a href="https://youtu.be/rKcoX3GrnJg?si=EA-jHxNQoa4IcoSu">PART 1</a></li>
<li><a href="https://youtu.be/cF6wATyWgro?si=EeQtIDJSuqkpQbVV">PART 2</a></li>
<li><a href="https://youtu.be/eKMnl2id1Fc?si=O2W19F3Vp1UC7Xad">PART 3</a></li>
</ul>
</li>
</ul>
<p>https://www.sidefx.com/community-main-menu/complete-a-z-terrain-handbook/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unity"><a class="header" href="#unity">Unity</a></h1>
<ul>
<li>
<p>sidefx</p>
<ul>
<li><a href="https://github.com/sideeffects/HoudiniEngineForUnity">https://github.com/sideeffects/HoudiniEngineForUnity</a>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/unity/pluginapi.html">https://www.sidefx.com/docs/houdini/unity/pluginapi.html</a></li>
<li><a href="https://github.com/sideeffects/HoudiniEngineForUnity/tree/Houdini20.5/Plugins/HoudiniEngineUnity/Scripts/Examples">https://github.com/sideeffects/HoudiniEngineForUnity/tree/Houdini20.5/Plugins/HoudiniEngineUnity/Scripts/Examples</a></li>
<li><a href="https://youtu.be/1qjRWmqbzp8&amp;t=578">Procedural Race Tracks for Mobile Games | Stoyan Dimitrov | GDC 2019</a></li>
</ul>
</li>
<li><a href="https://www.sidefx.com/tutorials/unity-starter-kit/">https://www.sidefx.com/tutorials/unity-starter-kit/</a>
<ul>
<li><a href="https://www.sidefx.com/contentlibrary/unity-starter-kit/">https://www.sidefx.com/contentlibrary/unity-starter-kit/</a></li>
</ul>
</li>
<li><a href="https://www.sidefx.com/learn/unity/">https://www.sidefx.com/learn/unity/</a>
<ul>
<li><a href="https://www.sidefx.com/docs/unity/">https://www.sidefx.com/docs/unity/</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p>유니티 엔진에서 후디니 엔진과 통신하는 것이므로 에디트모드일때만 동작한다.</p>
</li>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/unity/attributes.html">https://www.sidefx.com/docs/houdini/unity/attributes.html</a></p>
</li>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/unity/meshes.html">https://www.sidefx.com/docs/houdini/unity/meshes.html</a></p>
</li>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/unity/instancing.html">https://www.sidefx.com/docs/houdini/unity/instancing.html</a></p>
</li>
</ul>
<h2 id="-3"><a class="header" href="#-3"></a></h2>
<div class="table-wrapper"><table><thead><tr><th>attr</th><th></th></tr></thead><tbody>
<tr><td>unity_instance</td><td>point찍고 attr에 프리팝 경로 입력하면 알아서 생성해줌</td></tr>
<tr><td>unity_material</td><td></td></tr>
</tbody></table>
</div>
<p>collision_geo Adds a non-convex, non-rendered mesh collider
rendered_collision_geo Adds a non-convex, rendered mesh collider</p>
<p>lod</p>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/unity/meshes/lod.html">https://www.sidefx.com/docs/houdini/unity/meshes/lod.html</a></li>
</ul>
<p>lod_screensize</p>
<ul>
<li>
<p><a href="https://www.sidefx.com/docs/houdini/unity/terrain/scattering.html">https://www.sidefx.com/docs/houdini/unity/terrain/scattering.html</a></p>
</li>
<li>
<p><a href="https://docs.unity3d.com/ScriptReference/TerrainData.html">https://docs.unity3d.com/ScriptReference/TerrainData.html</a></p>
<ul>
<li>The TerrainData class stores heightmaps, detail mesh positions, tree instances, and terrain texture alpha maps.</li>
<li>The Terrain component links to the terrain data and renders it.</li>
<li>treeInstances</li>
<li>treePrototypes</li>
</ul>
</li>
<li>
<p><a href="https://docs.unity3d.com/ScriptReference/TreeInstance.html">https://docs.unity3d.com/ScriptReference/TreeInstance.html</a></p>
<ul>
<li>Contains information about a tree placed in the Terrain game object.</li>
<li>This struct can be accessed from the TerrainData Object.</li>
<li>Description</li>
</ul>
</li>
<li>
<p>color</p>
</li>
<li>
<p>heightScale</p>
</li>
<li>
<p>lightmapColor</p>
</li>
<li>
<p>position</p>
</li>
<li>
<p>prototypeIndex</p>
</li>
<li>
<p>rotation</p>
</li>
<li>
<p>widthScale</p>
</li>
<li>
<p><a href="https://docs.unity3d.com/ScriptReference/TreePrototype.html">https://docs.unity3d.com/ScriptReference/TreePrototype.html</a></p>
<ul>
<li>Simple class that contains a pointer to a tree prototype.</li>
<li>This class is used by the TerrainData gameObject.</li>
</ul>
</li>
<li>
<p>bendFactor</p>
</li>
<li>
<p>navMeshLod</p>
</li>
<li>
<p>prefab</p>
</li>
</ul>
<p>s@unity_hf_tree_prototype0
s@unity_hf_tree_prototype1
s@unity_hf_tree_prototype2</p>
<p>s@unity_hf_layer_type = "detail";</p>
<p>s@unity_hf_detail_prototype_texture = "Assets/Race_Track_Tools/Art/Textures/Grass/grass_clump_001.png";
f@unity_hf_detail_prototype_maxheight = 3;
f@unity_hf_detail_prototype_maxwidth = 3;
f@unity_hf_detail_prototype_minheight = 1;
f@unity_hf_detail_prototype_minwidth = 1;</p>
<p>f@unity_hf_detail_prototype_bendfactor = 50;
i@unity_hf_detail_prototype_rendermode = 0;</p>
<p>i@unity_hf_detail_distance = 200;
f@unity_hf_detail_density = 1;
i@unity_hf_detail_resolution_patch = 128;</p>
<h2 id="체크리스트"><a class="header" href="#체크리스트">체크리스트</a></h2>
<ul>
<li>인스턴스
<ul>
<li>unity_instance</li>
</ul>
</li>
<li>머티리얼
<ul>
<li>unity_material</li>
</ul>
</li>
<li>컬리전
<ul>
<li>collision_geo</li>
<li>rendered_collision_geo</li>
</ul>
</li>
<li>LOD
<ul>
<li>lod_0</li>
<li>lod_screensize</li>
</ul>
</li>
<li>식생같은 경우
<ul>
<li>unity_hf_tree_prototype1</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unreal"><a class="header" href="#unreal">Unreal</a></h1>
<ul>
<li><a href="https://www.sidefx.com/tutorials/ue4-starter-kit/">UNREAL STARTER KIT</a></li>
<li><a href="https://docs.unrealengine.com/5.0/ko/city-sample-quick-start-for-generating-a-city-and-freeway-using-houdini/">도시 샘플 퀵스타트 - Houdini를 사용해 도시와 고속도로 만들기</a>
<ul>
<li>도시, 고속도로</li>
</ul>
</li>
<li><a href="https://www.sidefx.com/titan/">Project Titan</a>
<ul>
<li>드래그 화물배치</li>
<li>파이프</li>
</ul>
</li>
<li><a href="https://www.mixtrn.com/houdini-engine-to-unreal-engine-workflow">Houdini Engine to Unreal Engine Workflow</a>
<ul>
<li>팬스</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="joy-of-vex"><a class="header" href="#joy-of-vex">Joy Of Vex</a></h1>
<ul>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex.html">https://www.tokeru.com/cgwiki/JoyOfVex.html</a>
<ul>
<li><a href="https://github.com/jtomori/vex_tutorial">https://github.com/jtomori/vex_tutorial</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLTXmnikJEYnBtSfn4LwKx5vpopwrInp18">Houdini Hangout - The Joy of VEX</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLcg9CGPYCmygYPz1dYyyShhoUYRLz_MIz">TWA 후디니의 정석 - JOY_OF_VEX(한국어.ver)</a></li>
<li><a href="https://github.com/kiryha/Houdini/wiki/vex-for-artists">https://github.com/kiryha/Houdini/wiki/vex-for-artists</a></li>
</ul>
<p><img src="tutorial/../res/graph_example.png" alt="graph_example.png" /></p>
<h2 id="list"><a class="header" href="#list">List</a></h2>
<ul>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex01.html">JoyOfVex01</a> basic assignment, component assignment, arithmetic manipulation</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex02.html">JoyOfVex02</a> length and distance functions, animate with @Time</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex03.html">JoyOfVex03</a> clamp and fit, waves</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex04.html">JoyOfVex04</a> chramp, using on attrib components, on time, on reranging outputs</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex05.html">JoyOfVex05</a> modulo, more arithmetic tricks (quantising), but show that often a chramp is easier (eg stepped chramp);</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex06.html">JoyOfVex06</a> point wrangle vs prim wrangle vs detail wrangle, user defined attributes</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex07.html">JoyOfVex07</a> using the other inputs on wrangles, do things to geometry based on other geometry</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex08.html">JoyOfVex08</a> noise, various types, how it can be scaled, vector vs scalar noise, why you might use vops here instead</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex09.html">JoyOfVex09</a> dot and cross product, fake lighting combing normals to a surface, vector maths primer</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex10.html">JoyOfVex10</a> relpointbbox</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex11.html">JoyOfVex11</a> if statements</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex12.html">JoyOfVex12</a> nearpoints, arrays</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex13.html">JoyOfVex13</a> for loops (ties nicely into arrays)</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex14.html">JoyOfVex14</a> creating geometry, deleting geometry, debugging vex</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex15.html">JoyOfVex15</a> copy sop, simple instance attributes (pscale)</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex16.html">JoyOfVex16</a> copy sop, midweight instance attributes (scale, N)</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex17.html">JoyOfVex17</a> copy sop, orient, quaternions</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex18.html">JoyOfVex18</a> intrinsics</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex19.html">JoyOfVex19</a> primuv, xyzdist</li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex20.html">JoyOfVex20</a> pointclouds, further learning</li>
</ul>
<h3 id="01"><a class="header" href="#01">01</a></h3>
<ul>
<li>Attribute Wrangle
<ul>
<li>Runs a VEX snippet to modify attribute values.</li>
<li>Wrangle : 다루다</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>@Cd</td><td>색상</td></tr>
<tr><td>@N</td><td>노말</td></tr>
<tr><td>@ptnum</td><td>해당 포인트 번호</td></tr>
<tr><td>@numpt</td><td>포인트 총 갯수</td></tr>
<tr><td>ch('scale')</td><td>채널</td></tr>
<tr><td>sin</td><td>사인</td></tr>
</tbody></table>
</div>
<pre><code class="language-vex">@Cd = @N;
@Cd = @P;
@Cd = @ptnum/@numpt;
@Cd = float(@ptnum) / ch('scale');
@Cd = sin(@ptnum);
</code></pre>
<p><a href="https://www.sidefx.com/docs/houdini/hom/hou/Geometry.html">https://www.sidefx.com/docs/houdini/hom/hou/Geometry.html</a>
<a href="https://www.sidefx.com/docs/houdini/hom/hou/Point.html">https://www.sidefx.com/docs/houdini/hom/hou/Point.html</a>
<a href="https://docs.python.org/3.13/library/math.html">https://docs.python.org/3.13/library/math.html</a>
<a href="https://www.sidefx.com/docs/houdini/hom/hou/index.html#parmtemplates_group">https://www.sidefx.com/docs/houdini/hom/hou/index.html#parmtemplates_group</a></p>
<pre><code class="language-python">
node = hou.pwd()
geo = node.geometry()

if not geo.findPointAttrib("Cd"):
    geo.addAttrib(hou.attribType.Point, "Cd", (1.0, 1.0, 1.0))

if not geo.findPointAttrib("N"):
    geo.addAttrib(hou.attribType.Point, "N", (0.0, 1.0, 0.0))

points = geo.points()

numpt = len(geo.points())                # @numpt
numpt = geo.intrinsicValue("pointcount") # @numpt

for point in points:
    P     = point.position()       # @P
    ptnum = point.number()         # @ptnum
    N     = point.attribValue("N") # @N

    point.setAttribValue("Cd", P)
</code></pre>
<pre><code class="language-python">import math

radian = 1.0
sin_value = math.sin(radian)
</code></pre>
<pre><code class="language-python">def AddParameters():
    parameters = [
        # hou.FloatParmTemplate(name, label, num_components, ...)
        hou.FloatParmTemplate("scale", "scale", 1, default_value=(1.0,), min=0.0, max=10.0),
    ]

    node = hou.pwd()
    parm_template_group = node.parmTemplateGroup()
    for param in parameters:
        param_name = param.name()
        if not node.parm(param_name):
            parm_template_group.append(param)
    node.setParmTemplateGroup(parm_template_group)
</code></pre>
<h3 id="02"><a class="header" href="#02">02</a></h3>
<p>length(@P) == distance(@P, {0, 0, 0})</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>chf</td><td>hou.FloatParmTemplate("scale", "scale", 1, default_value=(1.0,         ), min=0.0, max=10.0)</td></tr>
<tr><td>chv</td><td>hou.FloatParmTemplate("scale", "scale", 3, default_value=(1.0, 1.0, 1.0), min=0.0, max=10.0)</td></tr>
</tbody></table>
</div>
<p>fit(v, in_min, in_max, out_min, out_max);</p>
<p>@Time : Float time ($T)                                             |</p>
<h3 id="03"><a class="header" href="#03">03</a></h3>
<pre><code class="language-vex">float d = length(@P);
d *= ch('v_scale');
d += @Time;
@P.y = sin(d);
</code></pre>
<p>clamp(v, min, max);</p>
<h3 id="04"><a class="header" href="#04">04</a></h3>
<p>chramp</p>
<h3 id="05"><a class="header" href="#05">05</a></h3>
<p>trunc</p>
<h3 id="06"><a class="header" href="#06">06</a></h3>
<p>::pass</p>
<h3 id="07"><a class="header" href="#07">07</a></h3>
<p><a href="https://www.sidefx.com/docs/houdini/vex/functions/minpos.html">https://www.sidefx.com/docs/houdini/vex/functions/minpos.html</a>
minpos VEX function
Given a position in world space, returns the position of the closest point on a given geometry.</p>
<p><a href="https://www.sidefx.com/docs/houdini/vex/functions/nearpoint.html">https://www.sidefx.com/docs/houdini/vex/functions/nearpoint.html</a>
nearpoint VEX function
Finds the closest point in a geometry.</p>
<p>@P = point(1, 'P', @ptnum);
@P = @opinput1_P;</p>
<h3 id="08"><a class="header" href="#08">08</a></h3>
<p>noise
curlnoise
pnoise</p>
<h3 id="09"><a class="header" href="#09">09</a></h3>
<p>dot
cross</p>
<h3 id="10"><a class="header" href="#10">10</a></h3>
<p>normalize
relpointbbox</p>
<h3 id="11"><a class="header" href="#11">11</a></h3>
<p>if</p>
<h3 id="12"><a class="header" href="#12">12</a></h3>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Ctrl + /</td><td>라인 주석</td></tr>
</tbody></table>
</div>
<h3 id="13"><a class="header" href="#13">13</a></h3>
<pre><code class="language-vex">foreach( element; array)
{
    // do things to element
}
</code></pre>
<pre><code class="language-vex">for ( starting value; test; value increment)
{

}
</code></pre>
<h3 id="14"><a class="header" href="#14">14</a></h3>
<p>addpoint  // removepoint
addprim   // removeprim
addvertex // removevertex</p>
<h3 id="15"><a class="header" href="#15">15</a></h3>
<p>::pass</p>
<h3 id="16"><a class="header" href="#16">16</a></h3>
<p>::pass</p>
<h3 id="17"><a class="header" href="#17">17</a></h3>
<p>quaternion</p>
<pre><code class="language-vex">float angle = ch('angle');
vector axis = chv('axis');

@orient = quaternion(angle, axis);
</code></pre>
<pre><code class="language-vex">@N = {0,1,0};
float s = sin(@Time);
float c = cos(@Time);
@up = set(s,0,c);

@orient = quaternion(maketransform(@N, @up));
</code></pre>
<pre><code class="language-vex">matrix3 m = ident();
@orient = quaternion(m);


vector rot = radians(chv('euler'));
@orient = eulertoquaternion( rot, 0);


vector4 a = {0,0,0,1};
vector4 b = quaternion({0,1,0}*$PI/2);
@orient = slerp(a, b, ch('blend') );


@orient = qmultiply(@orient, extrarot);
matrix m = qconvert(@orient);
</code></pre>
<p>radians
qconvert</p>
<p><a href="https://www.sidefx.com/docs/houdini/vex/attribtypeinfo_suite.html">https://www.sidefx.com/docs/houdini/vex/attribtypeinfo_suite.html</a>
Sets the meaning of an attribute in geometry.
int  setattribtypeinfo(int geohandle, string attribclass, string name, string typeinfo)</p>
<h3 id="18"><a class="header" href="#18">18</a></h3>
<pre><code class="language-vex">matrix3 m = ident();
setprimintrinsic(0, 'transform', 0, m);
</code></pre>
<pre><code class="language-vex">matrix3 m = matrix3( myfancy4x4matrix);
matrix pft = primintrinsic(0,'packedfulltransform',@ptnum);
matrix3 rotandscale = matrix3(pft);
3@b = rotandscale;
</code></pre>
<h3 id="19"><a class="header" href="#19">19</a></h3>
<pre><code class="language-vex">vector uv = chv('uv');

@P = primuv(1,'P',0,uv);
@N = primuv(1,'N',0,uv);
</code></pre>
<pre><code class="language-vex">i@primid;
v@uv;
@dist;

@dist = xyzdist(1,@P, @primid, @uv);

@P = primuv(1,'P',@primid, @uv);
</code></pre>
<h3 id="20"><a class="header" href="#20">20</a></h3>
<pre><code class="language-vex">int pts[] = nearpoints(1,@P,ch('d'),25);
int pt;
vector pos;
foreach (pt; pts)
{
  pos = point(1,'P',pt);
  addpoint(0,pos);
}


int pts[] = pcfind(1,'P',@P,ch('d'),25);
int pt;
vector pos;
foreach (pt; pts)
{
  pos = point(1,'P',pt);
  addpoint(0,pos);
}
</code></pre>
<p>pcopen
pcfilter</p>
<pre><code class="language-vex">int pc = pcopen(0,'P',@P, ch('dist'), chi('maxpoints'));
@Cd = pcfilter(pc, 'Cd');
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="https://www.sidefx.com/titan/">PROJECT TITAN</a>
<ul>
<li>도시 배경</li>
</ul>
</li>
<li><a href="https://www.sidefx.com/pegasus/">PROJECT PEGASUS</a>
<ul>
<li>산 지형</li>
</ul>
</li>
<li><a href="https://www.sidefx.com/learn-main-menu/tech-demos/project-grot/">PROJECT GROT</a>
<ul>
<li>용암 지형</li>
</ul>
</li>
<li>PROJECT VITRUVIUS
<ul>
<li>??</li>
</ul>
</li>
</ul>
<h2 id="project-titan-stacking-tool"><a class="header" href="#project-titan-stacking-tool">PROJECT TITAN STACKING TOOL</a></h2>
<ul>
<li>
<p><a href="https://www.sidefx.com/tutorials/project-titan-stacking-tool/">https://www.sidefx.com/tutorials/project-titan-stacking-tool/</a></p>
<ul>
<li>by Thomas Tobin - <a href="https://www.artstation.com/thomasctobin">https://www.artstation.com/thomasctobin</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLXNFA1EysfYm0MPSArwg-Kdnb1fWyat1K">https://www.youtube.com/playlist?list=PLXNFA1EysfYm0MPSArwg-Kdnb1fWyat1K</a></li>
</ul>
</li>
<li>
<p>시뮬해서 떨어지게 하는 부분이 잼씀.</p>
</li>
<li>
<p>어럽네 중간에 디프리케이트된 노드랑 조금 개념에 안맞는게 있음.</p>
</li>
<li>
<p>pivot문제랑 py_max구하는 부분</p>
</li>
</ul>
<p>Groupd_props =&gt; gr_base_layer</p>
<h3 id="1--unreal-engine-setup"><a class="header" href="#1--unreal-engine-setup">1 | Unreal Engine Setup</a></h3>
<ul>
<li>
<p>속성</p>
<ul>
<li>AssetPath</li>
<li>Width</li>
<li>Height</li>
<li>Length</li>
<li>Rotation</li>
<li>Scale_MIN</li>
<li>Scale_MAX</li>
</ul>
</li>
<li>
<p>Create &gt; Place Actors &gt; Panel</p>
<ul>
<li>Geometry &gt; Box
<ul>
<li>Activate Brush Editing Editing Mode (Shift + 6)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Houdini</p>
<ul>
<li>Windows &gt; Houdini Engine Session Sync</li>
</ul>
</li>
</ul>
<h3 id="2--setting-up-the-hda"><a class="header" href="#2--setting-up-the-hda">2 | Setting up the HDA</a></h3>
<ul>
<li>
<p>Object Merge로 언리얼 DataTable을 가져오면 point에 attribute를 가지게 됨.</p>
</li>
<li>
<p><a href="https://www.sidefx.com/ja/forum/topic/86532/?page=1#post-374007">https://www.sidefx.com/ja/forum/topic/86532/?page=1#post-374007</a></p>
<ul>
<li>Labs Building From Patterns 편집</li>
</ul>
</li>
</ul>
<h4 id="정보를-불러와서-더미에-셋팅"><a class="header" href="#정보를-불러와서-더미에-셋팅">정보를 불러와서 더미에 셋팅</a></h4>
<ul>
<li>CSV Import 노드 (csv를 로드)
<ul>
<li>Fill Attribute Info from Header로 간편하게 로드하자</li>
</ul>
</li>
<li>필요시 Attribute Rename을 사용하여 이름을 바꾸자</li>
<li>Wrangle (Point)
<pre><code class="language-vex">  vector s = set(
      @Width,
      @Height,
      @Length
  );
  @scale = s;
  @P = {0, 0, 0};
</code></pre>
</li>
<li>Color
<ul>
<li>Color Type: Random from Attribute</li>
<li>Attribute : AssetPath</li>
</ul>
</li>
<li>Copy to Point - 박스랑
<ul>
<li>Pack and Instance</li>
</ul>
</li>
<li>Connectivity - Primitive 로 class 어트리뷰트로 각 박스별 그룹지어주고</li>
<li>Attribute Promote - 최대값을 저장해둔다
<ul>
<li>Original Name : class</li>
<li>Original Class : Primitive</li>
<li>New Class : Detail</li>
<li>Promotion Method : Maximum</li>
<li>Change New Name : max</li>
<li>Delete Original : 언체크</li>
</ul>
</li>
<li>Unpack
<ul>
<li>Transfer Attribute : *</li>
</ul>
</li>
</ul>
<pre><code class="language-txt">primitive:
    +class

detail:
    +max
</code></pre>
<h4 id="더미-위치-조정"><a class="header" href="#더미-위치-조정">더미 위치 조정</a></h4>
<p>class(primitive)를 point(variant)로 변환</p>
<ul>
<li>Foreach Primitive - Piece Attribute : class
<ul>
<li>Match Size
<ul>
<li>Justify Y : Min</li>
</ul>
</li>
<li>Bound</li>
<li>Attribute Transfer
<ul>
<li>Detail</li>
</ul>
</li>
</ul>
</li>
<li>Attribute Promote
<ul>
<li>Original Name : class (primitive)</li>
<li>New Name : variant (point)</li>
</ul>
</li>
<li>Null: INPUT_SCATTER</li>
</ul>
<pre><code class="language-txt">point:
    +variant

primitive:
    -class =&gt;  point:variant

detail:
    max
</code></pre>
<h3 id="3--packing-assets"><a class="header" href="#3--packing-assets">3 | Packing Assets</a></h3>
<h4 id="배치-구역-밑바닥"><a class="header" href="#배치-구역-밑바닥">배치 구역 밑바닥</a></h4>
<ul>
<li>Object Merge로 영역을 가져고</li>
<li>Group
<ul>
<li>Keep by Normal
<ul>
<li>Direction: 0, -1, 0</li>
<li>Spread Angle : 20</li>
</ul>
</li>
</ul>
</li>
<li>Blast</li>
<li>Reverse</li>
<li>Null : OUT_BOTTOM_LAYER</li>
</ul>
<h4 id="배치-구역-설정"><a class="header" href="#배치-구역-설정">배치 구역 설정</a></h4>
<p>OUT_BOTTOM_LAYER에 점을 뿌리고 variant를 랜덤화시킨다.</p>
<ul>
<li>Scatter and Algin 으로 점을 뿌리고
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/nodes/sop/scatteralign.html">https://www.sidefx.com/docs/houdini/nodes/sop/scatteralign.html</a></li>
<li>Point Count Method : By Density</li>
<li>Density Scale에 따라 오브젝트 크기도 달라짐</li>
</ul>
</li>
<li>Wrangle (Point)
<ul>
<li>@id = @ptnum;</li>
</ul>
</li>
<li>Attribute Randomize
<ul>
<li>Attribute Name : variant</li>
<li>Dimensions: 1</li>
<li>Distribution : Uniform(Discrete)</li>
<li>Max Value : detail("-1", "max", 0)</li>
<li>Spare Input : ../INPUT_SCATTER</li>
</ul>
</li>
<li>Attribute Cast
<ul>
<li>Attributes : variant</li>
<li>Precision: 16-bit integer</li>
</ul>
</li>
<li>Null: INPUT_SPREAD_POINTS</li>
</ul>
<pre><code class="language-txt">+point:id==@ptnum
+point:orient
+point:variant        // random from ../INPUT_SCATTER's detail:max
</code></pre>
<h4 id="iscale셋팅"><a class="header" href="#iscale셋팅">iscale셋팅</a></h4>
<ul>
<li>Copy to Point - INPUT_SPREAD_POINTS의 variant 기반으로 INPUT_SCATTER를 변형하며 뿌리기
<ul>
<li>Piace Attribute : variant</li>
<li>Pack and Instance</li>
</ul>
</li>
<li>Attribute Transfer
<ul>
<li>Detail도 활성화</li>
</ul>
</li>
<li>Attribute Randomize
<ul>
<li>Attribute Name : iscale</li>
<li>Attribute Class : Primitive</li>
<li>Distribution : Uniform(Discrete)</li>
<li>Dimensions : 1</li>
<li>Min Value:</li>
<li>Max Value:</li>
<li>Step Size:</li>
</ul>
</li>
<li>Unpack
<ul>
<li>Transfer Attribute : *</li>
</ul>
</li>
<li>Null : RANDOMIZE_ISCALE</li>
</ul>
<pre><code class="language-txt">point:
    variant
    id

primitive:
    +iscale

detail:max
</code></pre>
<h4 id="uv-layout을-사용한-배치"><a class="header" href="#uv-layout을-사용한-배치">uv layout을 사용한 배치</a></h4>
<ul>
<li>UV Layout
<ul>
<li>UV Attribute : P / ZX Projection</li>
<li>Island Scale Attribute: iscale</li>
<li>Axis Alignment : None</li>
<li>Packing
<ul>
<li>Scale: Fixed</li>
<li>Spread Islands in Cavities of Other Islands</li>
</ul>
</li>
<li>Targets
<ul>
<li>Pack Into : Islands From Second Input
<ul>
<li>두번째 입력으로 Object Merge: ../OUT_BOTTOM_LAYER &gt; Remesh TODO</li>
</ul>
</li>
<li>UV Attribute : P / ZX Projection</li>
</ul>
</li>
<li>Nonpacked Polygons : nonpacked</li>
</ul>
</li>
<li>Blast : nonpacked</li>
<li>Null : OUT_BOTTOM_LAYER_PACKED</li>
</ul>
<pre><code class="language-txt">point:
    variant
    id

primitive:
    iscale
    +group:nonpack

detail:
    max
    +coverage
    +numnopacked
</code></pre>
<h3 id="4--stacking-assets"><a class="header" href="#4--stacking-assets">4 | Stacking Assets</a></h3>
<p>50분 정도 내용이라 따라가기 힘듬</p>
<ul>
<li>
<p>Partion 노드는 deprecated.</p>
<ul>
<li>Use the Groups from Name node instead.</li>
</ul>
</li>
<li>
<p>Attribute Promote</p>
<ul>
<li>id(point) =&gt; id(Primitive)</li>
</ul>
</li>
<li>
<p>Pack</p>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/nodes/sop/pack.html">https://www.sidefx.com/docs/houdini/nodes/sop/pack.html</a></li>
</ul>
<pre><code class="language-txt">- Path Attribute: op:\`opfullpath('.')\`
- Name Attribute: id
- Create Packed Fragments: 체크 해제
- Transfer Attributes: *
</code></pre>
</li>
<li>
<p>Group : gr_base_layer</p>
</li>
</ul>
<pre><code class="language-txt">point:
    variant
    -id =&gt;  primitive:id

primitive:
    +id
    +path  ex) op:/obj/geo1/pack1/0
    iscale
    -group:nonpack

detail:
    -max
    -coverage
    -numnopacked
</code></pre>
<h4 id="피드백을-이용해서-한단씩-쌓기"><a class="header" href="#피드백을-이용해서-한단씩-쌓기">피드백을 이용해서 한단씩 쌓기</a></h4>
<ul>
<li>For-Loop with Feedback
<ul>
<li>Null: PROCESS</li>
<li>Null: FEEDBACK 은 나중에 머지용으로 빼두고</li>
</ul>
</li>
</ul>
<p><strong>PROCESS 에서 상단면을 구하고</strong></p>
<ul>
<li>Unpack</li>
<li>Group (gr_top_mesh)
<ul>
<li>Keep by Normal
<ul>
<li>Direction: 0, 1, 0</li>
<li>Spread Angle : 20</li>
</ul>
</li>
</ul>
</li>
<li>Blast (gr_top_mesh)</li>
<li>Group Promotion (gr_top_mesh)
<ul>
<li>Primitive to Point</li>
</ul>
</li>
</ul>
<p><strong>상단면에서 가장 높은 면만을 고른 뒤</strong></p>
<ul>
<li>Wrangle (Primitive)
<ul>
<li>f@py = @P.y;</li>
</ul>
</li>
<li>Attribute Promote
<ul>
<li>py(primitive) =&gt; py_max(detail)</li>
<li>Promotion Method : Maximum</li>
</ul>
</li>
<li>blast
<pre><code class="language-txt">@py=`detail(0, "py_max", 0)`
</code></pre>
</li>
</ul>
<p><strong>무리지어 묶는다</strong></p>
<ul>
<li>Pack (pack_for_cluster)</li>
<li>Cluster Points
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/nodes/sop/clusterpoints.html">https://www.sidefx.com/docs/houdini/nodes/sop/clusterpoints.html</a>
<ul>
<li>Point attribute가 cluster가 생기고 해당 클러스터 번호가 들어간다.</li>
</ul>
</li>
<li>Clusters: ch("spare_input0") * 1.5
<ul>
<li>Clust : (모여있는 )무리</li>
<li>Clusters 수치를 조절하여 뭉처있는 것들을 조절</li>
</ul>
</li>
<li>Spare Input 0 : `npoints(-2)`
<ul>
<li>The first spare input is -1, the second is -2, and so on</li>
</ul>
</li>
<li>Spare Input 1 : ../pack_for_cluster</li>
</ul>
</li>
<li>Attribute Promote
<ul>
<li>cluster:point &gt; primitive</li>
</ul>
</li>
<li>Unpack
<ul>
<li>Transfer Attribute : *</li>
</ul>
</li>
</ul>
<p><strong>무리를 감싸는 영역을 만들고</strong></p>
<ul>
<li>foreach primitive로 Cluster 구역별로 묶기
<ul>
<li>Piece Attribute : cluster</li>
</ul>
</li>
<li>Shrinkwrap (2D) 로 엮여있는것들을 묶어주고</li>
<li>Transform 조금작게 해주자
<ul>
<li>Uniform Scale: 0.8</li>
<li>Pivot Translate: $CEX/$CEY/$CEZ</li>
</ul>
</li>
<li>Remesh</li>
<li>Null: HIGHER_AREA</li>
</ul>
<p><strong>해당 영역에 다시 적층하자</strong></p>
<p>RANDOMIZE_ISCALE를 object merge로 가져오고, 다시 attribute randomize를 시켜주자. 그리고</p>
<ul>
<li>
<p>UV Layout</p>
<ul>
<li>UV Attribute : P / ZX Projection</li>
<li>Island Scale Attribute: iscale</li>
<li>Axis Alignment : None</li>
<li>Packing
<ul>
<li>Scale: Fixed</li>
<li>Spread Islands in Cavities of Other Islands</li>
</ul>
</li>
<li>Targets
<ul>
<li>Pack Into : Islands From Second Input
<ul>
<li>두번째 입력으로 Object Merge: ../OUT_BOTTOM_LAYER &gt; Remesh TODO</li>
</ul>
</li>
<li>UV Attribute : P / ZX Projection</li>
</ul>
</li>
<li>Nonpacked Polygons : nonpacked</li>
</ul>
</li>
<li>
<p>Blast : nonpacked</p>
</li>
<li>
<p>Attribute Promote</p>
<ul>
<li>id:point &gt; primitive</li>
</ul>
</li>
<li>
<p>Pack</p>
</li>
<li>
<p>그다음 FEEDBACK과 머지</p>
</li>
<li>
<p>Attribute Promote</p>
<ul>
<li>iscale:primitive =&gt; pscale:point</li>
</ul>
</li>
<li>
<p>Copy To Point - OUT_HIGH과</p>
<ul>
<li>Piace Attribute : variant</li>
<li>Pack and Instance</li>
<li>추가 Points by Copying : pscale orient</li>
</ul>
</li>
</ul>
<h3 id="5--simulation"><a class="header" href="#5--simulation">5 | Simulation</a></h3>
<ul>
<li>
<p>Group (gr_active)</p>
<ul>
<li>Point</li>
<li>BaseGroup: gr_base_layer</li>
</ul>
</li>
<li>
<p>Split: gr_activate</p>
<ul>
<li>unpack &gt; Null (ACTIVE)</li>
<li>unpack &gt; Null (NON_ACTIVE)</li>
</ul>
</li>
<li>
<p>NON_ACTIVE에서</p>
</li>
<li>
<p>Wrangle (point)</p>
<ul>
<li>f@active = 1;</li>
<li>v@v = chv("direction") * chf("boost") * rand(@ptnum);</li>
</ul>
</li>
<li>
<p>RBD Bullet Solver</p>
<ul>
<li>Output: Transfer Attribute : orient</li>
<li>OUT_OBJECT_PLACEMENT랑 grid랑 MatchSize하고 ACTIVE랑 머지한걸 input4에 넣음</li>
</ul>
</li>
<li>
<p>Timeshift</p>
<ul>
<li>Frame: 50</li>
</ul>
</li>
<li>
<p>Group : gr_inside_bound</p>
<ul>
<li>Keep in Bouding Region
<ul>
<li>Bouding Object(point or vertices only)로 감싸는 영역만 하고</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Blast : gr_inside_bound</p>
<ul>
<li>Delete Non Selected</li>
</ul>
</li>
<li>
<p>그리고 ACTIVE랑 머지</p>
</li>
</ul>
<p><strong>이제 포인트만 남기도록</strong></p>
<ul>
<li>Clean
<ul>
<li>Remove Attribs: <code>* ^N ^up ^orient ^scale ^pscale ^unreal_instance ^unity_instance</code></li>
</ul>
</li>
<li>Connectivity
<ul>
<li>Primitive</li>
</ul>
</li>
<li>Foreach Primitive - Piece Attribute: class</li>
<li>gr_piece</li>
<li>Wrangle (detail)
<ul>
<li>vector min;</li>
<li>vector max;</li>
<li>getbbox(min, max);</li>
<li>vector center = (min + max) / 2;</li>
<li>vector combo = set(center.x, min.y, center.z);</li>
<li>addpoint(-1, combo);</li>
</ul>
</li>
<li>Blast : gr_piece</li>
<li>Attribute Transfer 전부</li>
</ul>
<p>그러면 이제 끝</p>
<hr />
<h2 id="project-titan-cable-tool"><a class="header" href="#project-titan-cable-tool">PROJECT TITAN CABLE TOOL</a></h2>
<ul>
<li>
<p><a href="https://www.sidefx.com/tutorials/project-titan-cable-tool/">https://www.sidefx.com/tutorials/project-titan-cable-tool/</a></p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLXNFA1EysfYnkP5GncdwIVsZABbZ2z_Ud">https://www.youtube.com/playlist?list=PLXNFA1EysfYnkP5GncdwIVsZABbZ2z_Ud</a></li>
</ul>
</li>
<li>
<p>라인 활용 Vellum Hair를 이용한 시뮬레이션</p>
</li>
<li>
<p>Connect Adjacent Pieces 인접 조각 연결로 서브 케이블 만듬</p>
</li>
</ul>
<h3 id="2--create-the-main-cables"><a class="header" href="#2--create-the-main-cables">2 | Create the Main Cables</a></h3>
<ul>
<li>Circle</li>
<li>Mountain
<ul>
<li>Noise Along Vector 해제 및 XY만 활성화</li>
</ul>
</li>
<li>Connect Adjacent Pieces - 이렇게 하면 primitive갯수가 늘어나버림
<ul>
<li>Adjacent Points</li>
<li>Search Radius: 10</li>
</ul>
</li>
<li>Convert Line</li>
<li>Attribute Promote
<ul>
<li>restlength:primitive =&gt; minimum =&gt; point:pscale</li>
</ul>
</li>
<li>Attribute Transfer
<ul>
<li>앞서 mountain된것에 point:pscale만 넘겨준다</li>
</ul>
</li>
<li>Sweep
<ul>
<li>Line / Resample 한것을 첫번째 인풋으로</li>
<li>Surface Type: Columns</li>
</ul>
</li>
<li>Attribute Randomize
<ul>
<li>random:primitive</li>
</ul>
</li>
<li>Attribute Promote
<ul>
<li>random:primitive =&gt; random:point</li>
</ul>
</li>
<li>Group by Range (gr_line_pins)
<ul>
<li>Point</li>
<li>Invert Range</li>
<li>Conectivity/Affect Disconnected Geometry Seperately</li>
</ul>
</li>
<li>Vellum Hair
<ul>
<li>Constraint Type: String</li>
<li>Pin to Animation
<ul>
<li>Pin Points: gr_line_pins</li>
</ul>
</li>
</ul>
</li>
<li>Vellum Solver</li>
</ul>
<h3 id="3--create-the-small-cables"><a class="header" href="#3--create-the-small-cables">3 | Create the Small Cables</a></h3>
<h3 id="4--build-the-digital-asset"><a class="header" href="#4--build-the-digital-asset">4 | Build the Digital Asset</a></h3>
<ul>
<li>입력을 2개 추가한다
<ul>
<li>1번째 입력은 line을 대체</li>
<li>2번째 입력은 컬리전으로 Vellum Hair의 3번째 인자로 들어가게 된다.</li>
</ul>
</li>
</ul>
<h3 id="5--open-in-unreal"><a class="header" href="#5--open-in-unreal">5 | Open in Unreal</a></h3>
<ul>
<li>Attribute Create
<ul>
<li>unreal_material</li>
</ul>
</li>
</ul>
<h3 id="6--use-trimsheet-textures"><a class="header" href="#6--use-trimsheet-textures">6 | Use Trimsheet Textures</a></h3>
<ul>
<li>Sweep에서 Compute UVs</li>
</ul>
<p>UV를 수평으로</p>
<ul>
<li>Labs Trim Texture Utility
<ul>
<li>Initialization Mode: Generate from ID Map 으로 색으로 구분된 ID맵을 입력받아 trim을 생성</li>
</ul>
</li>
</ul>
<p>없으면 Grid를 활용</p>
<ul>
<li>Grid
<ul>
<li>Row는 ID갯수 +1만큼</li>
</ul>
</li>
<li>Top뷰(2번키)로, Select(s키) 포인트(2번키)로 선택후 Translate(t키)를 눌러 y축 조정</li>
<li>UV Project
<ul>
<li>Rotate: 90 / -180 / 0</li>
</ul>
</li>
<li>Primitive Split 으로 각 부분을 나눠주고</li>
<li>Trim Texture Utility
<ul>
<li>Initialzie누르면 됨.</li>
</ul>
</li>
<li>Labs Automatic Trim Texture
<ul>
<li>UV 크기 비율에 맞추어 알아서 레이아웃시켜줌</li>
</ul>
</li>
</ul>
<hr />
<h2 id="project-titan-platform-tool"><a class="header" href="#project-titan-platform-tool">PROJECT TITAN PLATFORM TOOL</a></h2>
<ul>
<li>외곽 라인 스케일 조절
<ul>
<li>convert line</li>
<li>primitive split</li>
<li>attrib promote
<ul>
<li>restlength:primitive =&gt; point</li>
</ul>
</li>
<li>primitive properties
<ul>
<li>Transform - Do Translation의 스케일 조정</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="project-titan-rails-tool"><a class="header" href="#project-titan-rails-tool">PROJECT TITAN RAILS TOOL</a></h2>
<p>:pass</p>
<h2 id="project-titan-fence-tool"><a class="header" href="#project-titan-fence-tool">PROJECT TITAN FENCE TOOL</a></h2>
<p>: pass</p>
<hr />
<h2 id="project-titan-building-tool"><a class="header" href="#project-titan-building-tool">PROJECT TITAN BUILDING TOOL</a></h2>
<h2 id="project-titan-ivy-tool"><a class="header" href="#project-titan-ivy-tool">PROJECT TITAN IVY TOOL</a></h2>
<p>ivy: 담쟁이덩굴</p>
<p>shrub 관목 (=bush)</p>
<h2 id="project-titan-tree-pivot-painter"><a class="header" href="#project-titan-tree-pivot-painter">PROJECT TITAN TREE PIVOT PAINTER</a></h2>
<h2 id="project-titan-vat-characters"><a class="header" href="#project-titan-vat-characters">PROJECT TITAN VAT CHARACTERS</a></h2>
<h2 id="project-titan-gpt-signage"><a class="header" href="#project-titan-gpt-signage">PROJECT TITAN GPT SIGNAGE</a></h2>
<h2 id="project-titan-train-tool"><a class="header" href="#project-titan-train-tool">PROJECT TITAN TRAIN TOOL</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-paths"><a class="header" href="#learning-paths">Learning Paths</a></h1>
<ul>
<li>튜토리얼이 vimeo로 된게 많은데 느릴시 CDN Priority 조정
<ul>
<li><a href="https://player.vimeo.com/flags?p=general">https://player.vimeo.com/flags?p=general</a></li>
</ul>
</li>
</ul>
<h2 id="learn--learning-paths--unity"><a class="header" href="#learn--learning-paths--unity"><a href="https://www.sidefx.com/learn/unity">Learn &gt; Learning Paths &gt; Unity</a></a></h2>
<h3 id="start-here"><a class="header" href="#start-here">START HERE</a></h3>
<ul>
<li>
<p><a href="https://www.sidefx.com/tutorials/unity-starter-kit/">UNITY STARTER KIT</a></p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLXNFA1EysfYl0noIUdMUSsG-TOpkm0-CQ">https://www.youtube.com/playlist?list=PLXNFA1EysfYl0noIUdMUSsG-TOpkm0-CQ</a></li>
<li>여러 툴들 소계</li>
<li>Tree
<ul>
<li>가지 - <strong>나중에 잔가지 부분 살펴볼것</strong>
<ul>
<li>Curve로 나무 기둥을 잡고</li>
<li>Resample - Subdivision Curve로 부드럽게 함</li>
<li>Facet으로 점 정리를 하고</li>
<li>기둥 중간에서 렌덤으로 위치를 잡고</li>
<li>distancefromtarget으로 바닥에서 멀어질 수록 짧게 가지가 자랄 수 있도록 한다
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/nodes/sop/distancefromtarget.html">https://www.sidefx.com/docs/houdini/nodes/sop/distancefromtarget.html</a></li>
</ul>
</li>
<li>가지가 자랄때는 Bend로 위를 향하게 하고 몇번 반복하고 Sweep하면 가지는 완성</li>
</ul>
</li>
<li>나뭇잎영역
<ul>
<li>가지 영역을 Bound/Remesh후 Ray하면 가지 영역을 랩핑한것과 같아짐</li>
<li>Remesh/ Smooth/ Peak하면 나뭇잎영역을 얻을 수 있음</li>
</ul>
</li>
<li>나뭇잎은
<ul>
<li>Grid 3장을 90도 각도로 겹쳐서 나뭇잎 영역에 뿌림</li>
</ul>
</li>
</ul>
</li>
<li>UNITY Starter Kit | Rock Tool
<ul>
<li>바위 영역
<ul>
<li>Voxel Mesh로 바위를 생성할 영역을 둥글게 만들어 주고</li>
<li>메인 바위는 Scatter로</li>
<li>주변 바위는 edgegroup to curve / scatter / peak으로 펼쳐서 뿌려준다</li>
<li>바위 설정은 Point VOP로 그라디언트로 색입히기(아레쪽이 어둡게)</li>
</ul>
</li>
</ul>
</li>
<li>UNITY Starter Kit | Modular Wall Tool
<ul>
<li>나무 타입
<ul>
<li>Box를 Poly Bevel로 부드럽게 한 후 9도정도 기울이게</li>
<li>mountain대신에 point jitter로 살짝 모양 변형</li>
<li>symmetrize로 앞뒤 같게</li>
</ul>
</li>
<li>바위 타입
<ul>
<li>lot_subdivision로 영역을 나누고</li>
<li>attr random - float point:Cd ramp</li>
<li>attr promote - point:Cd =&gt; - primitive:Cd</li>
<li>Poly Extrude : insert 마이너스
<ul>
<li>indivisual elements / output side은 필요없음</li>
</ul>
</li>
<li>Poly Extrude : distance
<ul>
<li>Local Control로 Distance Scale : Cd</li>
</ul>
</li>
<li>Attr noise - pscale</li>
<li>Divide</li>
<li>Poly Bevel - Scale by Attribute : pscale</li>
</ul>
</li>
</ul>
</li>
<li>FOLIAGE
<ul>
<li>모드 Leave/ Plant /Ivy</li>
<li>Leave
<ul>
<li>Line에 Sweep으로 윤곽을 잡고</li>
<li>p를 bbox의 y의 최대-최소 나누면 중간만 어두워지는데 그 부분을 포인트를 뿌려서 Boolean으로 잘라준다(box를 찌그려뜨려서)</li>
</ul>
</li>
<li>담쟁이처럼 물체따라 가는거
<ul>
<li>붙어있을 물체를 remesh하고 peak으로 부풀려주고</li>
<li>시작점받아서 붙어있을 물체에서 nearpoint로 해서 가까이 있는 점을 찾고</li>
<li>End점을 랜덤으로 뿌려주고</li>
<li>findshortestpath로 가지의 길을 냄</li>
<li>잎은 가지길에서 포인터 뿌려서</li>
<li>가지몸체는 poly wire로</li>
</ul>
</li>
</ul>
</li>
<li>UNITY Starter Kit | Edge Damage Tool
<ul>
<li>switch-if : npoints(0)==0</li>
<li>remesh 스므스 살짝 / smooth / normal / mountain / peak / normal 그리고 boolean</li>
</ul>
</li>
<li>UNITY Starter Kit | Level from PSD Tool
<ul>
<li>:pass</li>
</ul>
</li>
<li>UNITY Starter Kit | Placement Tool
<ul>
<li>:pass</li>
</ul>
</li>
<li>UNITY Starter Kit | Pipe Tool
<ul>
<li>커브에서 Bevel을 적용한 다음 그 꺽인 부분에 이음세를 넣는 방식</li>
</ul>
</li>
<li>UNITY Starter Kit | Platform Tool
<ul>
<li>테두리
<ul>
<li>영역을 Voxel Mesh로 만듬</li>
<li>split_prim_by_normal로 +Y Invert Selection으로 위쪽을 날림</li>
<li>group/edgegroup_to_curve로 위쪽 엣지(라인)을 잡음</li>
<li>peak으로 조절하고 Attr randomize로 N을 변경시킴(y는 0으로)</li>
<li>attr noise로 pscale을 변경시켜주고</li>
<li>transform으로 살짝 띄우고</li>
</ul>
</li>
<li>테두리 돌
<ul>
<li>platonic을 아래쪽을 잡아 늘리고</li>
<li>Boolean으로 cube를 이용해서 모서리 깍아줘서 테두리 돌을 만듬</li>
</ul>
</li>
<li>영역
<ul>
<li>Voxel Mesh에서 위쪽만 Mountain.</li>
<li>Attribute Noise로 Cd로 돌 영역을 색칠해서 작은 돌을 뿌림</li>
</ul>
</li>
</ul>
</li>
<li>Unity Starter Kit | Terrain Tool
<ul>
<li>:pass</li>
</ul>
</li>
<li>Unity Starter Kit | Road Tool
<ul>
<li>:pass</li>
</ul>
</li>
<li>UNITY Starter Kit | Level from WFC
<ul>
<li>영역을 isooffset으로 만들고</li>
<li>wfc_initialize과 Group : Bouding Volume으로 그룹핑하여 겹치는 영역을 Color로 검정색으로 만듬</li>
<li>wang_tiles_decoder해주고</li>
<li>blast - @name==0</li>
</ul>
</li>
<li>Unity Starter Kit | Trim Tool
<ul>
<li>:TODO 나중에 볼것 trim</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://www.sidefx.com/tutorials/getting-started-with-houdini-engine-for-unity/">GETTING STARTED WITH HOUDINI ENGINE FOR UNITY</a></p>
<ul>
<li>육각형 지형, HDA 생성, unity_instance</li>
<li>Attribute Create</li>
<li>Attribute Randomize</li>
</ul>
</li>
<li>
<p><a href="https://www.sidefx.com/tutorials/houdini-engine-for-unity-instancing/">HOUDINI ENGINE FOR UNITY | INSTANCING &amp; VARIATION</a></p>
<ul>
<li>Scatter and Align 로 뿌려넣고 unity_instance로 소환</li>
<li>Attribute Randomize
<ul>
<li>Options / Global Seed</li>
</ul>
</li>
<li>Parameter Description / Type: String / Tags / TagName: heuassetpath 로 엔진파라미터로 프리팹 받을 수 있도록 설정.</li>
</ul>
</li>
<li>
<p><a href="https://www.sidefx.com/tutorials/houdini-engine-for-unity-session-sync/">HOUDINI ENGINE FOR UNITY | SESSION SYNC</a></p>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/ref/panes/enginesessionsync.html">https://www.sidefx.com/docs/houdini/ref/panes/enginesessionsync.html</a></li>
<li>Houdini &gt; New Pane Tab Type &gt; Misc &gt; Houdini Engine SessionSync &gt; Start</li>
<li>Unity &gt; Houdini Engine &gt; Session Sync &gt; Connect to Houdini</li>
<li>유니티에서 hda 불러오면, 후디니에서도 보기 가능</li>
<li>유니티에서 New Node를 생성하면, 후디니에서도 생성됨. 후디니에서 편집가능.
<ul>
<li>유니티에서 Save Node로 저장하면 .hess(<code>H</code>oudini <code>E</code>ngine <code>S</code>ession<code>S</code>ync)</li>
<li>유니티에서 Load NodeSync로 불러오기 가능.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://www.sidefx.com/tutorials/games-quickstart/">GAMES QUICKSTART</a></p>
<ul>
<li>간단한 모델링, 그루핑, 어트리뷰트, HDA, Curve</li>
<li>Desktop 설정</li>
<li>단축키 C
<ul>
<li><a href="https://www.sidefx.com/tutorials/hotkeys/">HOTKEYS</a></li>
</ul>
</li>
<li>node
<ul>
<li>Poly Extrude</li>
<li>Poly Bevel</li>
<li>Poly Split</li>
<li>Bend</li>
<li>Edit</li>
<li>Fuse</li>
<li>Resample</li>
<li>Copy To Point</li>
<li>Orientation Along Curve // Curve에서 각도 유지
<ul>
<li>파라미터 조정을 통해 사슬과 같은 효과를 낼 수 있다.</li>
</ul>
</li>
<li>Copy To Curve == Orientation Along Curve + Copy To Point</li>
<li>Draw Curve // 축 기반으로 그리거나, 매쉬에 그릴 수 있음.</li>
<li>Match Size // 중점 이동</li>
<li>Trace // Traces curves from an image file or heightfield.</li>
</ul>
</li>
<li>Group
<ul>
<li>Group</li>
<li>Group by Range // with Tube, Poly Extrude</li>
<li>Group Combine</li>
<li>Group Promote</li>
</ul>
</li>
<li>Attribute
<ul>
<li>Attribute Create</li>
<li>Attribute Noise // Cd, scale, N, pscale</li>
<li>Attribute Randomize</li>
<li>Attribute Promote</li>
</ul>
</li>
<li>6 | MAKE GAME-READY ASSETS
<ul>
<li>1
<ul>
<li>File</li>
<li>Labs Game Res // Reduce, Auto UV, Bake</li>
<li>ROP FBX Output</li>
</ul>
</li>
<li>2
<ul>
<li>Poly Reduce</li>
<li>Auto UV</li>
<li>Soften Normals</li>
<li>Labs Map Baker</li>
</ul>
</li>
<li>블록 모서리 깍인 효과
<ul>
<li>Attribute Noise - pscale</li>
<li>Poly Bevel
<ul>
<li>Ignore Flat Edges</li>
<li>Scale By Attribute</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="https://www.sidefx.com/tutorials/houdini-digital-assets/">HOUDINI DIGITAL ASSETS</a></p>
<ul>
<li>사슬
<ul>
<li>Draw Curve - Resample - CopyToCurve
<ul>
<li>Apply Yaw
<ul>
<li>Yaw: 90</li>
</ul>
</li>
<li>Apply Roll or Twist
<ul>
<li>Full Twists: 7</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>팬스
<ul>
<li>노드
<ul>
<li>output, color</li>
<li>Point Jitter로 변형 (crooked)</li>
<li>Poly Bevel - Round</li>
<li>Attribute Noise - scale 로 높이조정</li>
<li>Attribute Noise - N 로 흩으러짐(회전) 효과</li>
<li>Distance Along Geometry
<ul>
<li>Output Mask로 Ramp값을 할당</li>
</ul>
</li>
<li>Attribute VOP
<ul>
<li>Import Point Attribute - mask</li>
<li>변형주고 scale에 할당.</li>
</ul>
</li>
<li>Labs Color Gradient로 y축 기반 색상 지정.</li>
<li>Copy To Curve
<ul>
<li>Target Type: Next Edge로 이어진 팬스</li>
<li>Target Up Vector 조절로 뒤집힘 방지.</li>
</ul>
</li>
</ul>
</li>
<li>HDA
<ul>
<li>Parameter</li>
<li>Match Current Definition</li>
</ul>
</li>
<li>vex: ch</li>
</ul>
</li>
<li>Type Properties &gt; Node &gt; Guide Geometry
<ul>
<li>가이드라인으로 와이어 프레임으로 보여짐.</li>
<li>Switch추가로 Toggle하여 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="sci-fi-level-design"><a class="header" href="#sci-fi-level-design"><a href="https://www.sidefx.com/learn/collections/sci-fi-level-design/">Sci Fi Level Design</a></a></h2>
<h3 id="sci-fi-panel-generator"><a class="header" href="#sci-fi-panel-generator">SCI FI PANEL GENERATOR</a></h3>
<ul>
<li>PART 1 | MODELING THE PANEL
<ul>
<li>PSD를 읽어 모델에 반영</li>
<li>GameDev Trace PSD File 노드
<ul>
<li>레이어 및 Brightness Threshold 지정 가능</li>
</ul>
</li>
<li>Split으로 그룹을 일단 나누고.</li>
<li>Blaster로 PSDLayerNumber 분리
<ul>
<li>@PSDLayerNumber=1 // Delete Non Selected</li>
</ul>
</li>
<li>GameDev Thicken</li>
<li>GameDev Axis Align</li>
<li>원통의 Bound를 구하고 Blast로 옆면을 때 Fuse로 중앙 점을 찾음
<ul>
<li>Attribute Randomize로 index를 설정하고</li>
<li>Copy - Stamp - Stamp Input 체크 및 Attribute Stamps에 index ?? 스탬프가 뭘까?</li>
<li>Switch 쪽에서 stamp("../copy1", "index", 0)</li>
<li>Create Meta Import Node
<ul>
<li>iteration, numiterations, value, ivalue</li>
</ul>
</li>
<li>Attribute Randomize의 Seed에
<ul>
<li>detail("../repeat_begin1_metadata1/", "iteration", 0)</li>
<li>rand(detail("../repeat_begin1_metadata1/", "iteration", 0) + $F)</li>
</ul>
</li>
</ul>
</li>
<li>Assemble : 매쉬 정리
<ul>
<li>Create Packed Geometry</li>
</ul>
</li>
<li>Blast로 원하는거 몇개 골라서 @P.z &gt; 5</li>
<li>Unpack</li>
<li>For-Each Connected Pieces
<ul>
<li>Transform
<ul>
<li>Pivot Translate : $CEX, $CEY, $CEZ (영상에선 preset 활용했음)</li>
<li>Scale: 1, 0, 0</li>
</ul>
</li>
<li>Scatter로 랜덤하게 좀 뿌려주고
<ul>
<li>Seed: detail("../repeat_begin1_metadata1/", "iteration", 0)</li>
</ul>
</li>
<li>Fuse로 붙어있는거 좀 정리해주고</li>
<li>Create Meta Import Node</li>
<li>새로운 갈래
<ul>
<li>Transform
<ul>
<li>Translate : - $CEX, - $CEY, - $CEZ</li>
<li>Scale: 0.1, 1, 1</li>
<li>Pivot Translate : $CEX, $CEY, $CEZ (영상에선 preset 활용했음)</li>
</ul>
</li>
<li>PolyBevel로 볼트처럼 만들고</li>
</ul>
</li>
<li>Copy To Point</li>
<li>볼트 종류는 Switch로 (switch2)</li>
<li>Attribute Randomize에서
<ul>
<li>Max Value: opninputs("../switch2/") - 1 : opninputs 인풋 갯수 반환</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>PART 2 | ADDING DETAIL
<ul>
<li>GameDev Trace PSD File 노드
<ul>
<li>Split으로 그룹을 일단 나누고. @Cd.r &gt; 5 - Invert Selection
<ul>
<li>그룹1 - 선으로 면에 이음선 넣기
<ul>
<li>GameDev Straight Skeleton 2D (Beta) / Facet / Fuse 로 선을 얻고 / Attribute Create N을 사이즈3. 값 0, 0, 1</li>
<li>Sweep - Skin Unclosed으로 Line과 엮어서 판을 만듬.</li>
<li>For-Each Connnected Piece
<ul>
<li>Boolean Shatter</li>
<li>Poly Bevel</li>
</ul>
</li>
<li>Attribute Delete - Cd</li>
</ul>
</li>
<li>그룹2
<ul>
<li>For-Each Connnected Piece
<ul>
<li>Fuse</li>
</ul>
</li>
<li>Transform으로 위치를 올려서</li>
<li>Ray 로 닿는 면과 달라붙도록 만듬.</li>
<li>Attribute Randomize - N</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>그냥 표면
<ul>
<li>GameDev Voxel Mesh</li>
<li>GameDev Measure Curvature</li>
<li>Blast - @Cd &gt; 0.2</li>
<li>Group - Keep by Normals - 0, 1, 0</li>
<li>Scatter</li>
</ul>
</li>
<li>추가 작업
<ul>
<li>GameDev Voxel Mesh - Resolution을 다르게 해서 high, low폴리 제작</li>
<li>Lattice</li>
<li>Poly Reduce</li>
<li>Group - 0, -1, 0의 하단 패널 부분을 선택</li>
<li>Blast</li>
<li>GameDev Delete Small Parts</li>
</ul>
</li>
<li>파이프
<ul>
<li>Group - Include by Edge - Min Edge Angle을 조정하여 각진 부분만 그룹핑</li>
<li>Poly Bevel</li>
<li>Subdivide</li>
</ul>
</li>
<li>파이프 클립
<ul>
<li>Clip으로 파이프 전체가 아닌 단면만을 사용가능.</li>
</ul>
</li>
<li>마무리
<ul>
<li>GameDev Remove Inside Faces</li>
<li>GameDev Auto UV - UV Unwrap</li>
<li>GameDev Soften Normal - Harden UV Seams</li>
</ul>
</li>
</ul>
</li>
<li>PART 3 | CREATING THE DIGITAL ASSET
<ul>
<li>HDA 설정</li>
</ul>
</li>
</ul>
<h3 id="sci-fi-crate-generator"><a class="header" href="#sci-fi-crate-generator">SCI FI CRATE GENERATOR</a></h3>
<ul>
<li>PART 1 | MODEL THE CRATE
<ul>
<li>Box / GameDev Axis Align / Null(IN)</li>
<li>Boolean - Shatter로 뚜껑을 구분지음 - A-Only Piece
<ul>
<li>Grid - 0, bbox("../IN/", D_YSIZE) * 0.8</li>
</ul>
</li>
<li>IN_Part_01
<ul>
<li>group / blast / polybevel / polyfill 로 윗단을 날리고 하단을 부드럽게 하고 윗단을 다시 채운다</li>
</ul>
</li>
</ul>
</li>
<li>PART 3 | BAKE THE TEXTURE MAPS</li>
<li>PART 4 | ADD DECALS</li>
</ul>
<h3 id="sci-fi-door-generator"><a class="header" href="#sci-fi-door-generator">SCI FI DOOR GENERATOR</a></h3>
<p>Box - PolyBevel 이랑 Boolean (Shatter) - Poly Expand 2D를 사용해서 문 패턴</p>
<p>그룹을 쉽게할 수 있는 Quick Group이라는 서브네트워크가 있음</p>
<h3 id="sci-fi-terminal--fuel-tanks"><a class="header" href="#sci-fi-terminal--fuel-tanks">SCI FI TERMINAL &amp; FUEL TANKS</a></h3>
<p>Carve랑 Boolean 조합 모양잡기</p>
<h3 id="sci-fi-stair-generator"><a class="header" href="#sci-fi-stair-generator">SCI FI STAIR GENERATOR</a></h3>
<p>Line을 Resample한것과 Line을 Bound한것을 Ray(Minimum Distance)시켜서 라인의 크기 방향이 변해도 꺽이는게 일정하도록 끝부분만 꺽이게 만듬.</p>
<ul>
<li>PART 3 | UNWRAP UVS FOR TRIM SHEET
<ul>
<li>UV 입힐때는 일단 파츠별로 색 입히고 ID할당한다음 Foreach돌면서 UV Transform활용하여 트림에 맞춰서 위치시킴</li>
</ul>
</li>
</ul>
<h3 id="sci-fi-core"><a class="header" href="#sci-fi-core">SCI FI CORE</a></h3>
<ul>
<li>Tube로 삼각형 만들 수 있고</li>
<li>Copy - Rotate.y : 360 / ch("ncy") 으로 Total Number에 맞게 회전하게 했다.</li>
<li>Lab Lighting이라는 노드도 있네</li>
</ul>
<h3 id="sci-fi-level-builder"><a class="header" href="#sci-fi-level-builder">SCI FI LEVEL BUILDER</a></h3>
<ul>
<li>커브를 Fuse의 Snap To: Grid 로 그리드로 스냅핑했다. 그런 후 Grid와 Copy To Point. Fuse로 중복 점 제거, Labs Dissolve Flat Edges로 엣지정리.</li>
<li>Poly Extrude를 하면서 Output Front를 빼면 벽이 처짐</li>
<li>Measure Curvature로 인코스/아웃코스 구분하여 코너에 배치할 물체 회전</li>
</ul>
<hr />
<h3 id="dungeon-props"><a class="header" href="#dungeon-props">DUNGEON PROPS</a></h3>
<h4 id="2-model-the-wood-crates"><a class="header" href="#2-model-the-wood-crates">2. MODEL THE WOOD CRATES</a></h4>
<p>스타일라이즈 형태의 나무제질</p>
<ul>
<li>Attribute Noise로 Cd를 확인하고 그다음 pscale로 변경
<ul>
<li>Poly Bevel시 Offsetting에서 Scale By Attribute로 pscale 사용.</li>
</ul>
</li>
<li>Remesh Grid로 잘게 쪼개주고</li>
<li>Point VOP
<ul>
<li>Vein과 Displace Along Normal로 나이테에 따른 높이조절</li>
<li>정사각형같은 건 Cylinder. 판자같은건 Linear로 함</li>
<li>GUARD TOWER 2 | WOOD WALL PART 9 참조</li>
</ul>
</li>
</ul>
<h3 id="wfc-dungeon-generator"><a class="header" href="#wfc-dungeon-generator">WFC DUNGEON GENERATOR</a></h3>
<ul>
<li>WaveFunctionCollapse
<ul>
<li><a href="https://www.gridbugs.org/wave-function-collapse/">https://www.gridbugs.org/wave-function-collapse/</a></li>
<li><a href="https://github.com/merrell42/model-synthesis">https://github.com/merrell42/model-synthesis</a></li>
<li><a href="https://www.youtube.com/watch?v=X8pNAKtWllc">WaveFunctionCollapse Supercharged with PDG for Level Generation | Paul Ambrosiussen | HOUDINI HI...</a></li>
</ul>
</li>
<li>Wang
<ul>
<li><a href="https://www.boristhebrave.com/permanent/24/06/cr31/stagecast/wang/blob_g.html">https://www.boristhebrave.com/permanent/24/06/cr31/stagecast/wang/blob_g.html</a></li>
<li><a href="https://www.boristhebrave.com/permanent/24/06/cr31/stagecast/wang/blob.html">https://www.boristhebrave.com/permanent/24/06/cr31/stagecast/wang/blob.html</a></li>
</ul>
</li>
</ul>
<p>while True:            # 반복
x = collapse(wave) # 붕괴
if x is False:
break
propagate(wave, x) # 전파</p>
<ul>
<li>
<p>Labs WFC Initialize Grid로 그리드 판을 만들고</p>
<ul>
<li>이미지 로드시 1픽셀 단위로 포인트가 생성되기 때문에 주의 .</li>
</ul>
</li>
<li>
<p>2D Wave Funtion Collapse 로 함수를 적용</p>
</li>
<li>
<p>Labs Wang Tiles Decorator로 포인트를 만들고</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Wang_tile">https://en.wikipedia.org/wiki/Wang_tile</a></li>
<li><a href="https://skidvis.itch.io/sharkjets-3d-wang-tileset">https://skidvis.itch.io/sharkjets-3d-wang-tileset</a></li>
</ul>
</li>
<li>
<p>Copy To Point 로 Labs Wang Tiles Sample에서 미리 준비해둔 타일 조각들을 배치한다</p>
<ul>
<li>Piece Attribute: name</li>
</ul>
</li>
<li>
<p>Blast @name==0 으로 빈칸 삭제 가능</p>
</li>
<li>
<p>Extract Silhouette의 Y축으로 하면 실루엣도 얻을 수 있음.</p>
</li>
<li>
<p>Delete Small Parts로 삐져나온것도 정리 가능</p>
</li>
<li>
<p>Labs Attribute Value Replace로 Wang번호를 게임엔진에서 사용할 문자열로 변경할 수 있다.</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=YDpVUl213yo&amp;list=PLXNFA1EysfYny9oR45bFI7edFi_A2-8b8&amp;index=4">WFC Dungeon | Part 3 | Add Walls and Cliffs</a></p>
<ul>
<li>라바랑 배치쪽은 나중에 보도록 하자</li>
</ul>
</li>
</ul>
<hr />
<h3 id="guard-tower"><a class="header" href="#guard-tower">Guard Tower</a></h3>
<ul>
<li>
<p>made in Houdini 16.5 for Beginner by Kenny Lammers</p>
</li>
<li>
<p><a href="https://www.sidefx.com/learn/collections/guard-tower/">https://www.sidefx.com/learn/collections/guard-tower/</a></p>
</li>
<li>
<p><a href="https://www.sidefx.com/media/uploads/tutorial/indiepixel/guard_tower_project_files.zip">https://www.sidefx.com/media/uploads/tutorial/indiepixel/guard_tower_project_files.zip</a></p>
</li>
<li>
<p>좋았던점</p>
<ul>
<li>나이태 부분</li>
<li>볼트의 우둘투둘한 부분</li>
<li>콜리전 영역만들기</li>
</ul>
</li>
</ul>
<h4 id="ground-part"><a class="header" href="#ground-part">GROUND PART</a></h4>
<ul>
<li>GUARD TOWER 1 | GROUND PART 1 | CREATING THE GROUND ASSET
<ul>
<li>hda 만들기 : grid - uvflatten</li>
</ul>
</li>
<li>GUARD TOWER 1 | GROUND PART 2 | ADDING NOISE TO THE GROUND
<ul>
<li>mountain 적용</li>
<li>Point VOP로 Noise를 주고 Cd에 맵핑
<ul>
<li>shader에 lerp값으로 사용</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 1 | GROUND PART 3 | ADDING MATERIALS WITH HOUDINI ENGINE
<ul>
<li>UV Transform
<ul>
<li>Scale</li>
</ul>
</li>
<li>Attribute Create 로 머티리얼 지정가능
<ul>
<li>Name: unity_material</li>
<li>String: Assets/Gaurd_Tower/Art/Shared_Textures/Ground/Blend_Materials/Ground_Blended_MAT.mat</li>
<li>Unity 에디터 &gt; Houdini Engine &gt; Plugin Settings &gt; ADVANCED &gt; Unity Material Attribute : unity_material (기본값)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="wood-wall-part"><a class="header" href="#wood-wall-part">WOOD WALL PART</a></h4>
<ul>
<li>GUARD TOWER 2 | WOOD WALL PART 1 | CREATING A WOOD PLANK
<ul>
<li>Box</li>
<li>Group
<ul>
<li>Group Name : $OS
<ul>
<li>$OS : Operator String. Contains the current OP’s name. 노드 이름</li>
<li>H20.5 Legacy Preset &gt; Save As Permanent Defaults</li>
</ul>
</li>
</ul>
</li>
<li>Attribute Randomize</li>
<li>Poly Bevel
<ul>
<li>Offsetting
<ul>
<li>Distance : Scale By Attribute</li>
<li>Point Offset Scale : randbevel</li>
</ul>
</li>
</ul>
</li>
<li>Point
<ul>
<li>Attribute: Normal(N)</li>
<li>VExpression: set(0, 0, 1)</li>
</ul>
</li>
<li>Mountain</li>
<li>Point
<ul>
<li>Attribute: Normal(N)</li>
<li>VExpression: set(0, 1, 0)</li>
</ul>
</li>
<li>Mountain</li>
<li>UV Flatten</li>
<li>UV Layout</li>
<li>Normal
<ul>
<li>Cusp Angle 을 조절해서 하드/소프트 한 느낌 조정</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 2 | ASSEMBLING THE WOOD WALL
<ul>
<li>Type Properties &gt; Tools &gt; Context &gt; TAB Submenu Path : Shape Utils/</li>
<li>만들어진 hda가지고 위로 Copy
<ul>
<li>Translate.y : bbox("../gt_wood_plank_shape1/", D_YSIZE)</li>
</ul>
</li>
<li>옆으로 Copy</li>
<li>Offset용 Transform</li>
<li>Clip: Keep Primitive Above the Plane</li>
<li>Clip: Keep Primitive Below the Plane</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 3 | CREATING THE WALL POSTS
<ul>
<li>Transform
<ul>
<li>Translate.y : -bbox("../gt_wood_plank_shape1/", D_YMIN)</li>
</ul>
</li>
<li>Transform
<ul>
<li>Translate.z : -bbox("../gt_wood_plank_shape1/", D_ZSIZE) * 0.5</li>
</ul>
</li>
<li>기타
<ul>
<li>Box
<ul>
<li>Center.y : ch("sizey") * 0.5</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 4 | PLACING POSTS
<ul>
<li>Line
<ul>
<li>Origin.x : -ch("dist") * 0.5</li>
<li>Length : bbox("../wall_copy", D_XSIZE)</li>
</ul>
</li>
<li>Carve 로 지지대 새울 위치 조정
<ul>
<li>Second U : 1 - ch("domainu1")</li>
</ul>
</li>
<li>Transform
<ul>
<li>Translate.z : bbox("../wall_copy", D_ZMAX) + bbox("gt_wood_post_shape1/", D_ZSIZE) * 0.5</li>
</ul>
</li>
<li>Copy To Point</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 5 | CREATING BOLTS FOR THE WALL
<ul>
<li>Tube (Polygon)
<ul>
<li>Center.y : ch("height") * 0.5</li>
</ul>
</li>
<li>튜브 2개로 볼트만듬</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 6 | PLACING THE BOLTS
<ul>
<li>라인 활용 post에 ray를 쏴서 bolt를 Copy To Point</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 7 | VARIATION WITH COPIES
<ul>
<li>foreach
<ul>
<li>Create Meta Import Node
<ul>
<li>detail("../plank_loop_data/", "iteration", 0)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 8 | HI RES DISPLACEMENT
<ul>
<li>high res 모델링</li>
<li>Object Merge로 불러오고</li>
<li>Blast로 영역 구분</li>
<li><strong>Wall 나이테</strong>
<ul>
<li>VDB From Polygon
<ul>
<li>Voxel Size : 0.002</li>
</ul>
</li>
<li>Convert VDB (Polygon)</li>
<li>Point VOP
<ul>
<li>Vein 으로 나무 나이테 효과
<ul>
<li>Vein Spacing : 6</li>
<li>Vein Attenuation: 1.5</li>
<li>Vein Frequency : 5</li>
<li>Noise Frequency : 0.5 / 4 / 2</li>
</ul>
</li>
<li>Display Among Normal 에 연결
<ul>
<li>Scale : -0.005</li>
</ul>
</li>
</ul>
</li>
<li><strong>Bolt 모퉁이</strong>
<ul>
<li>VDB From Polygon
<ul>
<li>Voxel Size : 0.002</li>
</ul>
</li>
<li>Convert VDB (Polygon)</li>
<li>Labs Measure Curvature
<ul>
<li>곡률(Curvature)을 구하고 후에 VOP를 이용 변화량에 맞게 노이즈 적용할거임</li>
<li>r은 모퉁이가 될 것이고</li>
<li>g는 접합부가 될꺼임</li>
</ul>
</li>
<li>Point VOP
<ul>
<li>Anti-Aliased Noise
<ul>
<li>3D Frequency : 1.5</li>
<li>Roughness : 0.6</li>
</ul>
</li>
<li>(Cd.r * Tubulent Noise) + Anti-Aliased Noise 계산하고</li>
<li>Display Among Normal 에 연결
<ul>
<li>Scale : 0.01</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 9 | HIGH RESOLUTION POSTS
<ul>
<li>Post 기둥에 나이테효과주기.
<ul>
<li>윗단계처럼 옆면에 나이테 효과 주고</li>
<li><strong>상단은 원형 나이테를 만들어주자</strong></li>
<li>Group - tops
<ul>
<li>Keep in Bounding Region으로 윗 영역만 잡아주고</li>
</ul>
</li>
<li>Group Combine
<ul>
<li>left랑 tops를 intersect해서 lefttop을 만듬</li>
</ul>
</li>
<li>Smooth</li>
<li>Point VOP
<ul>
<li>(Turbulent Noise + P.xz) =&gt; ripple =&gt; Cd</li>
</ul>
</li>
<li>Attribute Blur
<ul>
<li>Cd</li>
</ul>
</li>
<li>@P.y += @Cd.r * chf("Scale")</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 10 | BAKING TEXTURES IN HOUDINI
<ul>
<li>벽/기둥/나사에 색깔을 입히고</li>
<li>Object Merge로 Low/High을 불러오고 Low, High순서로</li>
<li><strong>Labs Simple Baker</strong></li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 11 | LAYOUT THE WALL ASSET
<ul>
<li>curve로 영역을 만들고</li>
<li>Reverse</li>
<li>Attribute Wrangle(Point)
<ul>
<li>@P.x = rint(@P.x / 2) * 2;</li>
<li>@P.z = rint(@P.z / 2) * 2;</li>
</ul>
</li>
<li>Resample
<ul>
<li>Length: 2</li>
</ul>
</li>
<li>PolyFrame 면을 따라 Point Normal생성
<ul>
<li>Entity: Point</li>
<li>Style: First Edge</li>
<li>Normal Name : 체크 해제</li>
<li>Tangent Name : N</li>
</ul>
</li>
<li>Group
<ul>
<li>allpts</li>
</ul>
</li>
<li>PolyCut
<ul>
<li>Cut Points: allpts</li>
<li>Strategy: Cut</li>
</ul>
</li>
<li>그 다음으로 foreach - Blast (1) - Copy To Point해서 울타리를 쳐준다.</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 12 | COMPLETING THE WALL ASSET
<ul>
<li>울타리의 봉우리 뚜껑을 만들어 준다</li>
<li>Curve 영역에서</li>
<li>Remesh</li>
<li>Group
<ul>
<li>Include By Edges
<ul>
<li>Enable</li>
<li>Unshared Edges</li>
</ul>
</li>
</ul>
</li>
<li>Color</li>
<li>Attribute Blur
<ul>
<li>Attributes : Cd</li>
</ul>
</li>
<li>Point Wrangle
<ul>
<li>@P.y += @Cd.r * chf("Shape");</li>
</ul>
</li>
<li>Normal</li>
<li>Point VOP
<ul>
<li>@Cd.r * Turbulent Noise =&gt; Displace Along Normal =&gt; @P</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 2 | WOOD WALL PART 13 | SETTING UP THE WALL ASSET IN UNITY
<ul>
<li>HDA설정</li>
<li>Type Properties
<ul>
<li>Operator Path
<ul>
<li>Name : wallmodel</li>
<li>Op Filter : Any SOP</li>
</ul>
</li>
<li>Operator Path
<ul>
<li>Name : usercurve</li>
<li>Op Filter : Any SOP</li>
</ul>
</li>
</ul>
</li>
<li>Object Merge
<ul>
<li>Object 1 : <code>chsop("../wallmodel")</code></li>
</ul>
</li>
<li>Object Merge
<ul>
<li>Object 1 : <code>chsop("../usercurve")</code></li>
</ul>
</li>
<li>유니티에서
<ul>
<li>UNITY_MESH</li>
<li>HDA
<ul>
<li>Unity 에디터 &gt; Houdini Engine &gt; New Curve Asset
<ul>
<li>Reverse</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="sandbag-part"><a class="header" href="#sandbag-part">Sandbag Part</a></h4>
<ul>
<li>GUARD TOWER 3 | SANDBAG PART 1 | CREATING THE SANDBAG ASSET
<ul>
<li>Subdivide</li>
<li>Sculpt</li>
<li>Soft Peak
<ul>
<li>코너 부분만 그룹으로 잡아서</li>
</ul>
</li>
<li>Smooth</li>
<li>UV Flatten
<ul>
<li>Flatting Contrains
<ul>
<li>Seams에 가운데 가로로 빙둘러싼 엣지를 선택하고</li>
</ul>
</li>
</ul>
</li>
<li>UV Layout</li>
<li>Normal</li>
</ul>
</li>
<li>GUARD TOWER 3 | SANDBAG PART 2 | CREATING THE SANDBAG WALL PATTERN
<ul>
<li>Labs Edge Group To Curve
<ul>
<li>Group은 가운데 가로로 빙둘러싼 엣지를 선택하여 샌드백의 봉제선 모양을 만들어주자</li>
<li>Thickness
<ul>
<li>Thicken을 선택해서</li>
</ul>
</li>
</ul>
</li>
<li>그 다음으로 High res버전
<ul>
<li>VDB From Polygons</li>
<li>Convert VDB</li>
<li>Point VOP
<ul>
<li>@P.xz =&gt; Boxes =&gt; Displace Among Normal =&gt; @P</li>
</ul>
</li>
<li>Smooth</li>
</ul>
</li>
<li>앞서만든 모래주머니로 울타리
<ul>
<li>앞에서 만든것 처럼 영역만들고 모래주머니 단을 만들어주자</li>
<li>Foreach
<ul>
<li>Resample</li>
<li>Point Jitter</li>
<li>PolyFrame
<ul>
<li>Tangent Name : N</li>
</ul>
</li>
<li>Copy And Transform으로 단을 쌓을 포인트들을 만들어주고
<ul>
<li>Copy Number Attribute : copynum</li>
</ul>
</li>
<li>Attribute Promote
<ul>
<li>Original Name : copynum</li>
<li>Original Class : Primitive</li>
<li>New Class : Point</li>
<li>Promotion Method : Maximum</li>
</ul>
</li>
<li>Point Wrangle
<ul>
<li>지그제그 효과</li>
<li>int id = @copynum / 2;</li>
<li>if (id &gt; 2) { @P += @N * chf("offset"); }</li>
<li>@P += @N * chf("push");</li>
</ul>
</li>
</ul>
</li>
<li>Foreach
<ul>
<li>Copy To Point로 모래주머니를 쌓자</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 3 | SANDBAG PART 3 | CREATING THE SANDBAG WALL ASSET
<ul>
<li>HDA설정</li>
<li>Type Properties
<ul>
<li>Operator Path</li>
</ul>
</li>
</ul>
</li>
<li>GUARD TOWER 3 | SANDBAG PART 4 | COMPLETING THE SANDBAG WALL
<ul>
<li>유니티에 배치</li>
<li>샌드백 벽에 Labs Calculate Occlusion을 추가해서 Cd에 오쿨루젼 정보를 추가</li>
</ul>
</li>
</ul>
<h4 id="ladder-part"><a class="header" href="#ladder-part">LADDER PART</a></h4>
<ul>
<li>GUARD TOWER 4 | LADDER PART 1 | BUILDING A LADDER</li>
<li>GUARD TOWER 4 | LADDER PART 2 | CREATING THE LADDER DIGITAL ASSET</li>
<li>GUARD TOWER 4 | LADDER PART 3 | LADDER TRANSFORM FIX
<ul>
<li>pass</li>
</ul>
</li>
<li>GUARD TOWER 4 | LADDER PART 4 | COMPLETING THE LADDER
<ul>
<li>Group 유니티에서 컬리전
<ul>
<li>Group Name: collision_geo</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="tower-part"><a class="header" href="#tower-part">Tower Part</a></h4>
<ul>
<li>GUARD TOWER 5 | TOWER PART 1 | BUILDING THE BASE</li>
<li>GUARD TOWER 5 | TOWER PART 2 | BUILDING THE TOWER HOUSE
<ul>
<li>pass</li>
</ul>
</li>
</ul>
<h4 id="oilbarrel-part"><a class="header" href="#oilbarrel-part">OilBarrel Part</a></h4>
<ul>
<li>
<p>The Barrel is in <a href="https://www.dropbox.com/sh/1ck8tiizis73gnf/AAB5C0YzLlSd9UbVs21xsLVAa?dl=0">there</a></p>
</li>
<li>
<p>GUARD TOWER 6 | OILBARREL PART 1 | BUILDING THE OIL BARREL</p>
<ul>
<li>pass</li>
</ul>
</li>
<li>
<p>GUARD TOWER 6 | OIL BARREL PART 2 | BARREL STACKING</p>
<ul>
<li>여기서는 컬리젼 영역을 만들려고
<ul>
<li>VDB From Polygon</li>
<li>Convert VDB</li>
<li>Tetrahedralize( Convex Hull ) 노드를 쓰는데 해당 노드는 16.0 부터 지원을 안한다</li>
<li>대신 Shrinkwrap 를 쓰면 동일한 결과를 얻을 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="무료"><a class="header" href="#무료">무료</a></h2>
<ul>
<li><a href="https://www.sidefx.com/tutorials/foundations-book/">https://www.sidefx.com/tutorials/foundations-book/</a>
<ul>
<li><a href="https://media.sidefx.com/uploads/article/foundations-book/houdini_foundations_19_5_01.pdf">https://media.sidefx.com/uploads/article/foundations-book/houdini_foundations_19_5_01.pdf</a></li>
<li><a href="https://media.sidefx.com/uploads/article/foundations-book/19_5_foundations_projectfiles.zip">https://media.sidefx.com/uploads/article/foundations-book/19_5_foundations_projectfiles.zip</a></li>
<li><a href="https://www.sidefx.com/tutorials/foundations-overview/">https://www.sidefx.com/tutorials/foundations-overview/</a></li>
</ul>
</li>
</ul>
<p><a href="https://learn.unity.com/project/getting-started-with-houdini-unity">https://learn.unity.com/project/getting-started-with-houdini-unity</a></p>
<ul>
<li><a href="https://www.dokak.net/">독학.net</a>
<ul>
<li><a href="https://www.dokak.net/medieval-bricks">https://www.dokak.net/medieval-bricks</a></li>
<li><a href="https://www.dokak.net/rain-drops-effects">https://www.dokak.net/rain-drops-effects</a></li>
</ul>
</li>
<li>TWA 후디니의 정석
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLcg9CGPYCmyhq9oPLhCKUjdnjYaJoDNR2">HOUDINI 최초 입문 강의</a></li>
<li>joy of vex
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLcg9CGPYCmygYPz1dYyyShhoUYRLz_MIz">JOY_OF_VEX(한국어.ver)</a></li>
<li><a href="https://www.tokeru.com/cgwiki/JoyOfVex">https://www.tokeru.com/cgwiki/JoyOfVex</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://www.youtube.com/c/houdini3d/videos">https://www.youtube.com/c/houdini3d/videos</a></li>
<li><a href="http://wordpress.discretization.de/geometryprocessingandapplicationsws19/2019/10/17/lecture-progress/">http://wordpress.discretization.de/geometryprocessingandapplicationsws19/2019/10/17/lecture-progress/</a></li>
<li>모팩
<ul>
<li><a href="https://cafe.naver.com/sidefx/9600">https://cafe.naver.com/sidefx/9600</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLZmHHyN_lDlBlw9Rwn8hKEh7mUXw21EgH">Houdini FX Class</a></li>
</ul>
</li>
<li><a href="https://anopara.gumroad.com/">https://anopara.gumroad.com/</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLBTpSOAI0EwC8WosDEf6aHCi9JNypAiAB">후디니 유저인터페이스&amp; 활용</a></li>
<li><a href="https://vimeo.com/298979142">QuickTips Houdini 17: Visualize Pieces and Cluster with Voronoi Sops in Houdini 17</a></li>
<li>Procedural Bridge with Houdini and Unreal Engine 4 (UE4) - Showcase
<ul>
<li><a href="https://www.youtube.com/watch?v=YDeJ5CluShc">https://www.youtube.com/watch?v=YDeJ5CluShc</a></li>
<li><a href="https://reveron3d.com/portfolio/procedural-bridge-with-houdini-and-unreal-engine-4-ue4/">https://reveron3d.com/portfolio/procedural-bridge-with-houdini-and-unreal-engine-4-ue4/</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/watch?v=XS1IpC3qAP0">Randomly generated procedural homes in Houdini tutorial</a></li>
<li><a href="https://blog.naver.com/edgerider/221530848164">[Houdini]간단한 Procedure UV</a></li>
<li>Houdini/Ari Danesh(필수강좌)
<ul>
<li><a href="http://cgamefancy.tistory.com/category/Houdini/Ari%20Danesh%28%ED%95%84%EC%88%98%EA%B0%95%EC%A2%8C%29">http://cgamefancy.tistory.com/category/Houdini/Ari%20Danesh%28%ED%95%84%EC%88%98%EA%B0%95%EC%A2%8C%29</a></li>
<li><a href="http://cgamefancy.tistory.com/category/Houdini/Ari%20Danesh%28%EA%B0%95%EC%A2%8C%ED%95%B4%EC%84%9D%29">http://cgamefancy.tistory.com/category/Houdini/Ari%20Danesh%28%EA%B0%95%EC%A2%8C%ED%95%B4%EC%84%9D%29</a></li>
</ul>
</li>
<li><a href="https://www.youtube.com/playlist?list=PLX9r8Fg9lByAFTU-GUo1kMDor93ezqNNZ">Houdini 30 Day Introduction to Python</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLd959VTYXCB747UsN1EV8_bLUVEhhtL3i">Foundation Module - The Foundation Project</a></li>
</ul>
<h3 id="youtube-channel"><a class="header" href="#youtube-channel">Youtube Channel</a></h3>
<ul>
<li>
<p><a href="https://www.youtube.com/c/CGArtistAcademy">CGArtistAcademy</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/c/LoveDo">LoveDo</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/channel/UCnLGDYYL_6LcUT3TMSNdvSA">c0d2x</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/c/MotionDesignersCommunityTV">MotionDesignersCommunityTV</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/c/ResilientPictureCompany">ResilientPictureCompany</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/c/fxguide">https://www.youtube.com/c/fxguide</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/c/MIXTraining">https://www.youtube.com/c/MIXTraining</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/@rohandalvi">https://www.youtube.com/@rohandalvi</a></p>
<ul>
<li><a href="https://www.youtube.com/playlist?list=PLf_sfQuBdc3SrwXW6SfiRKzI3Oqj0XIvR">Intro to Houdini</a></li>
<li><a href="https://lucylueng.myblog.arts.ac.uk/2021/01/25/week1-rock-cabin/">https://lucylueng.myblog.arts.ac.uk/2021/01/25/week1-rock-cabin/</a></li>
</ul>
</li>
<li>
<p><a href="https://vimeo.com/173658697">Wagner’s Webinars: Houdini VEX</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/@cgside">cgside</a></p>
<ul>
<li><a href="https://www.patreon.com/cgside">https://www.patreon.com/cgside</a></li>
</ul>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=NfizT369g60">Procedural World Generation of Ubisoft’s Far Cry 5 | Etienne Carrier | Houdini HIVE Utrecht</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=FodXp5BkENk">Building the World of 'The Ascent'</a></p>
</li>
<li>
<p><a href="https://www.youtube.com/playlist?list=PLv8HciXoFYX8xGBC8ufmNamFdUMT0fhHf">Houdini  Tutorials - Pixel Fondue</a></p>
</li>
</ul>
<h2 id="p"><a class="header" href="#p">P</a></h2>
<ul>
<li>
<p><a href="https://www.youtube.com/@IndiePixel3D">IndiePixel3D</a></p>
<ul>
<li><a href="https://www.sidefx.com/profile/IndiePixel/">https://www.sidefx.com/profile/IndiePixel/</a></li>
</ul>
</li>
<li>
<p>Simon Verstraete</p>
<ul>
<li>Simon is a tech Artist that loves building procedural tools and assets.</li>
<li><a href="https://www.youtube.com/@simonhoudini5074">https://www.youtube.com/@simonhoudini5074</a></li>
<li><a href="https://www.artstation.com/siver">https://www.artstation.com/siver</a></li>
<li><a href="https://siver.gumroad.com/">https://siver.gumroad.com/</a></li>
</ul>
</li>
<li>
<p>Simon Trümpler</p>
<ul>
<li><a href="https://80.lv/articles/006sdf-river-simulation-with-simonschreibt/">https://80.lv/articles/006sdf-river-simulation-with-simonschreibt/</a></li>
<li><a href="https://www.youtube.com/@HoudiniSimon/">https://www.youtube.com/@HoudiniSimon/</a></li>
<li><a href="https://simonschreibt.de/">https://simonschreibt.de/</a></li>
</ul>
</li>
<li>
<p>Radu Cius</p>
<ul>
<li><a href="https://www.youtube.com/@RaduCius">https://www.youtube.com/@RaduCius</a></li>
<li><a href="https://www.artstation.com/raducius/store?tab=digital_product">https://www.artstation.com/raducius/store?tab=digital_product</a></li>
<li><a href="https://rart.gumroad.com/">https://rart.gumroad.com/</a></li>
</ul>
</li>
</ul>
<h2 id="책"><a class="header" href="#책">책</a></h2>
<ul>
<li><a href="https://www.youtube.com/c/JunichiroHorikawa/videos">후디니로 구현하는 알고리즘 디자인</a>
<ul>
<li>원제 : ALGORITHMIC DESIGN WITH HOUDINI HOUDINIではじめる自然現象のデザイン 소득공제
<ul>
<li><a href="https://www.youtube.com/c/JunichiroHorikawa/videos">https://www.youtube.com/c/JunichiroHorikawa/videos</a></li>
</ul>
</li>
<li>책 부록 소스: <a href="https://vielbooks.com/294">https://vielbooks.com/294</a>
<ul>
<li>암호: hdn320</li>
<li><a href="https://drive.google.com/u/0/uc?id=1HbSqAaeS7YG-3IDQXBjFN22GUbiT2v8O&amp;export=download">1</a></li>
<li><a href="https://drive.google.com/u/0/uc?id=1VUrIc4QW4hNbewxVa-AfxNw32q2peMr1&amp;export=download">2</a></li>
<li><a href="https://drive.google.com/u/0/uc?id=1ml4auLWl8gjN16I8HGklBwHDP-GBSWSv&amp;export=download">3</a></li>
<li><a href="https://drive.google.com/u/0/uc?id=1fs5fyDzqooK4Zr3iWfwn22hbqgNkgYlS&amp;export=download">4</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="-4"><a class="header" href="#-4">???</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=YMOGLxNs0Jk">Houdini Tutorial Edge Damage</a></li>
<li><a href="https://houdinist.tistory.com/category/%ED%9B%84%EB%94%94%EB%8B%88%20%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC%20%EC%86%8C%EA%B0%9C">https://houdinist.tistory.com/category/후디니%20튜토리얼%20소개</a></li>
</ul>
<h2 id="기타"><a class="header" href="#기타">기타</a></h2>
<ul>
<li><a href="https://github.com/sideeffects/GameDevelopmentToolset">https://github.com/sideeffects/GameDevelopmentToolset</a></li>
<li><a href="https://github.com/wqaetly/HoudiniSamples">https://github.com/wqaetly/HoudiniSamples</a></li>
<li><a href="https://houdinifx.jp/blog/gamedev-texture-sheet-%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6/">https://houdinifx.jp/blog/gamedev-texture-sheet-%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6/</a></li>
<li><a href="https://blog.naver.com/edgerider/220602291985">https://blog.naver.com/edgerider/220602291985</a></li>
<li><a href="https://microbot.ch/new/procedural-building-modules/">https://microbot.ch/new/procedural-building-modules/</a></li>
<li><a href="https://blog.naver.com/marnich/221659754394">https://blog.naver.com/marnich/221659754394</a></li>
<li><a href="https://www.orbolt.com/">https://www.orbolt.com/</a>
<ul>
<li>Create, upload, and share Houdini Digital Assets</li>
</ul>
</li>
</ul>
<h2 id="etc2"><a class="header" href="#etc2">etc2</a></h2>
<ul>
<li>
<p>cascadeur - deep learning pose predication tool</p>
</li>
<li>
<p><a href="https://youtu.be/aKuEJY9wJ58?t=1867">하운드13의 '프로젝트 M'의 처절한 전투를 표현하기 위한 언리얼 엔진 활용법 | 언리얼 서밋 2021</a></p>
<ul>
<li>블러드 이펙트</li>
</ul>
</li>
<li>
<p><a href="https://youtu.be/6Fg5fcmBcC4?t=2040">언리얼 서밋 | 2020 | TA가 구현해본 대규모 캐릭터 시스템 - 1,000개의 캐릭터가 끊김없이 나오게 만들기</a></p>
<ul>
<li>언리얼LOD생성 퀄리티가 낮아 LOD생성을 후디니에서 함</li>
</ul>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=pde5LWXhd9o">에픽 라이브 | 러셀 | UE5에서 한국적인 아파트 절차적으로 생성하기</a></p>
<ul>
<li>번외 후디니가 아닌 블루프린트 만으로 절차적 생성</li>
</ul>
</li>
<li>
<p>에픽 라이브 | 언리얼 엔진 이펙트에 후디니 활용하기</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=rKcoX3GrnJg">1</a></li>
<li><a href="https://www.youtube.com/watch?v=cF6wATyWgro">2</a></li>
<li><a href="https://www.youtube.com/watch?v=eKMnl2id1Fc">3</a></li>
</ul>
</li>
<li>
<p><a href="https://www.rohandalvi.net/advmodeling">https://www.rohandalvi.net/advmodeling</a></p>
</li>
<li>
<p><a href="https://qiita.com/jyouryuusui/items/ad15495a702ee957dbe8">ディニ子をつくる：Houdiniでキャラクターモデリング</a></p>
<ul>
<li>후디니 케릭터 모델링</li>
</ul>
</li>
</ul>
<h2 id="copmany"><a class="header" href="#copmany">Copmany</a></h2>
<ul>
<li>SEGA (용과 같이)
<ul>
<li><a href="https://techblog.sega.jp/search?q=houdini">https://techblog.sega.jp/search?q=houdini</a></li>
</ul>
</li>
<li>폴리포니 디지털 (그란 투리스모)
<ul>
<li><a href="https://www.youtube.com/watch?v=57GG1bAngcE">Gran Turismo 7 | Polyphony Digital | Houdini Connect</a></li>
<li><a href="https://www.polyphony.co.jp/publications/">https://www.polyphony.co.jp/publications/</a>
<ul>
<li><a href="https://www.polyphony.co.jp/publications/#CEDEC2022-4">https://www.polyphony.co.jp/publications/#CEDEC2022-4</a></li>
<li><a href="https://www.polyphony.co.jp/publications/#CEDEC2019-4">https://www.polyphony.co.jp/publications/#CEDEC2019-4</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://blog.toylogic.co.jp/tag/houdini">https://blog.toylogic.co.jp/tag/houdini</a></li>
<li><a href="https://academy.cgworld.jp/contents/search?q%5Bkeyword%5D=houdini">https://academy.cgworld.jp/contents/search?q%5Bkeyword%5D=houdini</a></li>
</ul>
<h2 id="gdc"><a class="header" href="#gdc">GDC</a></h2>
<ul>
<li><a href="https://gdcvault.com/play/1027521/Procedural-Systems-for-Marvel-s">HIVE2021 Procedural Systems for "Marvel's Spider-Man: Miles Morales" and "Ratchet &amp; Clank: Rift Apart" (Presented by Houdini)</a></li>
<li><a href="https://gdcvault.com/play/1035368/Tool-Development-Stories-from-the">GDC25 Tool Development Stories from the Game Tools Team at Houdini (Presented by Houdini)</a>
<ul>
<li><a href="https://www.artstation.com/polypixel/">https://www.artstation.com/polypixel/</a></li>
</ul>
</li>
<li><a href="https://gdcvault.com/play/1035413/Tencent-Games-Developer-Summit-The">GDC25 Tencent Games Developer Summit: The Procedural Way: Reconstruct Mega City of Qin Dynasty (Presented by Tencent Games)</a></li>
<li><a href="https://youtu.be/H4r_69WNE9o">Video games Created using Houdini</a></li>
</ul>
<h2 id="person"><a class="header" href="#person">person</a></h2>
<h3 id="luiz-kruel"><a class="header" href="#luiz-kruel">LUIZ KRUEL</a></h3>
<ul>
<li><a href="https://www.luizkruel.com/">https://www.luizkruel.com/</a></li>
<li><a href="https://www.youtube.com/watch?v=-LHj7-kROoo">GDC2017 - Technical Artist Bootcamp: Introduction to Proceduralism</a></li>
<li><a href="https://www.youtube.com/watch?v=eawAPiUliPE">GDC 2018 - Game Development Tips and Tricks | Luiz Kruel</a></li>
<li><a href="https://www.youtube.com/watch?v=7X-r_XarMLI">"Game" Development Tools | Luiz Kruel | SIGGRAPH 2019</a></li>
</ul>
<h3 id="多喜-建一-타키켄이치"><a class="header" href="#多喜-建一-타키켄이치">多喜 建一 타키켄이치</a></h3>
<h3 id="erik-hallberg"><a class="header" href="#erik-hallberg">Erik Hallberg</a></h3>
<ul>
<li>
<p><a href="https://www.youtube.com/watch?v=emeTkdTQgGA">[NDC21-비주얼아트&amp;사운드] Making Hard Surface Easy</a></p>
<ul>
<li><a href="https://www.youtube.com/watch?v=HZd4hQJ2MfA">Embark Asset Processor | Erik Hallberg | GDC HIVE 2023</a></li>
<li>참고 <a href="https://www.youtube.com/watch?v=l5XRaL1eN_8">Creating Procedural Welding Seams In Houdini</a></li>
</ul>
</li>
<li>
<p>Subdivision</p>
<ul>
<li>마스터하기 어려움</li>
<li>토폴로지에 대한 이해</li>
</ul>
</li>
<li>
<p>Zbrush</p>
<ul>
<li>Dynamesh, Polish</li>
<li>파괴적</li>
</ul>
</li>
</ul>
<p>로우폴리 작업
하이폴리 대비
만들기 쉬움
UV작업 쉬움
하이폴리에서 로우폴리로 전환시 날카롭거나 평평한 면이 뭉개지는 경우가 있음.
불린작업
원통형 나사
원형 패임
나사 생성
나무 덧댈 영역 + 나무 조각낼 평면
용접할 영역이 있는 박스
손잡이의 주름영역
접합부 casting seam
커스텀 UV 함수
sharp edge 분리 - 보기 좋은 노말맵 만들기 위해
Torus/pipe에서 적절한 seam 찾기
외곡된 uv는 따로 분리해서 경계지점을 찾고 최단거리로 자름
기울어진 uv영역은 서로 평행이거나, 가장긴 직선을 찾아내서 기울임 제거
머티리얼, 크기, AO가능 여부를 판별해서 uv영역 겹치기</p>
<h3 id="paul-ambrosiussen"><a class="header" href="#paul-ambrosiussen">Paul Ambrosiussen</a></h3>
<ul>
<li><a href="https://www.youtube.com/@paulambrosiussen/videos">https://www.youtube.com/@paulambrosiussen/videos</a></li>
<li><a href="https://www.ambrosiussen.com/work-1/tooldev">https://www.ambrosiussen.com/work-1/tooldev</a></li>
<li><a href="https://www.sidefx.com/profile/Ambrosiussen/">https://www.sidefx.com/profile/Ambrosiussen/</a></li>
<li>Python States for Houdini TDs
<ul>
<li><a href="https://ambrosiussen.gumroad.com/l/pythonstatesforhoudini">https://ambrosiussen.gumroad.com/l/pythonstatesforhoudini</a></li>
</ul>
</li>
<li><a href="https://youtu.be/bCcmwdrSTvM">Game Development Made Easy Using Houdini | Paul Ambrosiussen | GDC 2018</a></li>
<li><a href="https://www.youtube.com/watch?v=_YGdUkDETkQ">Rapid Level Creation for Unity Mobile | Paul Ambrosiussen | GDC 2019</a></li>
<li><a href="https://www.youtube.com/watch?v=X8pNAKtWllc">WaveFunctionCollapse Supercharged with PDG for Level Generation | Paul Ambrosiussen | HOUDINI HI...</a></li>
<li><a href="https://www.youtube.com/watch?v=H2_38R-V9Gw">Python States | Paul Ambrosiussen | Games Workshop</a></li>
</ul>
<h3 id="이규영"><a class="header" href="#이규영">이규영</a></h3>
<ul>
<li><a href="https://www.artstation.com/peter_k_lee">https://www.artstation.com/peter_k_lee</a></li>
<li><a href="https://blog.naver.com/furyedea255">https://blog.naver.com/furyedea255</a></li>
<li><a href="https://www.youtube.com/watch?v=lyiI6B8-ntc">[게임] RP7의 아트 디렉션과 파이프라인 | 언리얼 서밋 온라인 2022</a></li>
<li><a href="https://www.youtube.com/watch?v=DbIKoNfSSGc">블리자드 배경아티스트 귬규영 -2부-</a></li>
</ul>
<h3 id="matthew-vitalone"><a class="header" href="#matthew-vitalone">Matthew Vitalone</a></h3>
<ul>
<li><a href="https://vimeo.com/261901539">Creating Real-Time Oceans for Call of Duty: WWII | Matt Vitalone | GDC 2018</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=mMKViq1Bv8M">youtube</a></li>
</ul>
</li>
</ul>
<h3 id="radu-cius"><a class="header" href="#radu-cius">Radu Cius</a></h3>
<ul>
<li><a href="https://www.artstation.com/raducius">https://www.artstation.com/raducius</a></li>
<li><a href="https://rart.gumroad.com/">https://rart.gumroad.com/</a></li>
</ul>
<h3 id="viktors-anfimovs"><a class="header" href="#viktors-anfimovs">viktors anfimovs</a></h3>
<ul>
<li><a href="https://viktorsanfimovs.gumroad.com/">https://viktorsanfimovs.gumroad.com/</a></li>
</ul>
<h3 id="luis-garcia"><a class="header" href="#luis-garcia">Luis Garcia</a></h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=bNIjkxB_zi8">Procedural Art for Indies // Luis Garcia // GDC 2017</a></li>
<li><a href="https://www.youtube.com/watch?v=-e-Cmi0dFQ0">Simplifying Indie GameDev Workflows | Luis Garcia | GDC 2019</a></li>
</ul>
<pre><code class="language-vex">// ref: https://www.emilsvfx.lv/blog/hou_rope_vex/

vector A = point(0, "P", 0);
vector B = point(0, "P", @numpt - 1);

float L = 12.8;
float gravity = chf("gravity", 0.5);

float d = distance(A, B);
if (L &lt; d)
{
    warning("Rope too short!");
    return;
}

int pt = @ptnum;
if (pt == 0) 
{
    @P = A;
    return;
}

if (pt == @numpt-1)
{
    @P = B;
    return;
}

float t = float(pt) / float(@numpt-1);
vector pos = lerp(A, B, t);

// Apply sag with gravity control
float sag = sin(t * PI) * (L - d) * gravity;
pos.y -= sag;

@P = pos;
</code></pre>
<h3 id="juanjo-martínez"><a class="header" href="#juanjo-martínez">Juanjo Martínez</a></h3>
<ul>
<li><a href="https://www.youtube.com/c/JuanjoMart%C3%ADnezVFX/">https://www.youtube.com/c/JuanjoMart%C3%ADnezVFX/</a></li>
<li><a href="https://github.com/juanjo4martinez">https://github.com/juanjo4martinez</a></li>
</ul>
<h3 id="nikola-damjanov"><a class="header" href="#nikola-damjanov">NIKOLA DAMJANOV</a></h3>
<ul>
<li><a href="https://www.artstation.com/nikoladamjanov">https://www.artstation.com/nikoladamjanov</a></li>
<li><a href="https://www.sidefx.com/contentlibrary/cops-mega-file/">COPs Mega File</a></li>
<li><a href="https://www.sidefx.com/tutorials/the-complete-a-z-terrain-handbook/">THE COMPLETE A-Z TERRAIN HANDBOOK</a></li>
<li><a href="https://www.youtube.com/watch?v=eE01Z-zc54U">EPC2022 | Nikola Damjanov | Living Procedurally</a></li>
</ul>
<h3 id="adrienlambert"><a class="header" href="#adrienlambert">adrienlambert</a></h3>
<ul>
<li><a href="https://adrienlambert.gumroad.com/">https://adrienlambert.gumroad.com/</a></li>
<li><a href="https://www.youtube.com/@AdrienLambertvfx/">https://www.youtube.com/@AdrienLambertvfx/</a></li>
<li><a href="https://adrienlambert.gumroad.com/l/TbWQr">UVs LAST HOPE / Houdini Indie HDA</a></li>
<li><a href="https://adrienlambert.gumroad.com/l/pythfx">How not to suck at Python / SideFX Houdini</a></li>
<li><a href="https://adrienlambert.gumroad.com/l/pYaGH">Tutorial series - Procedural Cliffs with SideFX houdini</a></li>
</ul>
<h3 id="timucin-ozger"><a class="header" href="#timucin-ozger">Timucin Ozger</a></h3>
<ul>
<li><a href="https://www.artstation.com/timucinozger/">https://www.artstation.com/timucinozger/</a></li>
<li><a href="https://www.youtube.com/@StudioOriented">https://www.youtube.com/@StudioOriented</a></li>
<li><a href="https://www.timucinozger.com/">https://www.timucinozger.com/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ta"><a class="header" href="#ta">TA</a></h1>
<ul>
<li><a href="https://www.zhihu.com/people/iiiiiiiffffffffffff">iiiiiiiffffffffffff</a></li>
<li><a href="https://feikepostmes.com/about/">Feike Postmes</a></li>
<li><a href="https://reveron3d.com/about-me/">Adolfo Reverón</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="팁"><a class="header" href="#팁">팁</a></h1>
<h3 id="fbx-머티리얼별-색칠"><a class="header" href="#fbx-머티리얼별-색칠">FBX 머티리얼별 색칠</a></h3>
<p>파일로 fbx불러오고
파티션 Rule : $MAT하면 머티리얼별로 그룹이 생김.
Color로 해당 그룹 색칠</p>
<h3 id="점-선-면"><a class="header" href="#점-선-면">점 선 면</a></h3>
<p>면/선 =&gt; 점
Add - Delete Geometry But Keep the Points</p>
<p>면 =&gt; 선
Ends - Close U: Unroll with New Points
Convert Line</p>
<p>선 =&gt; 면
Skin</p>
<p>Poly Fill</p>
<h3 id="아이콘모양-변경-유지"><a class="header" href="#아이콘모양-변경-유지">아이콘모양 변경 유지</a></h3>
<p>C/Z로 컬러/모양을 띄우고 Ctrl을 누른후 드래그 드랍으로 노드를 변경하면 나중 노드들도 반영됨.</p>
<h3 id="자동-저장-횟수"><a class="header" href="#자동-저장-횟수">자동 저장 횟수</a></h3>
<ul>
<li>기본값 1분으로 되어있다. 바꾸려면
<ul>
<li>Edit &gt; Preferences &gt; Save and Load Options &gt; Auto Save Every x Minutes</li>
</ul>
</li>
</ul>
<h3 id="이전-버전-노드가-안보일때는"><a class="header" href="#이전-버전-노드가-안보일때는">이전 버전 노드가 안보일때는</a></h3>
<ul>
<li>Assets &gt; Asset Definition Toolbar &gt; Show Always</li>
<li>예)
<ul>
<li>Curve</li>
<li>Lab Cylinder Generator</li>
</ul>
</li>
</ul>
<h3 id="color-correction"><a class="header" href="#color-correction">Color correction</a></h3>
<ul>
<li>감마: Edit&gt; Color Settings&gt; Color correction&gt; Gamma&gt; 1
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/render/linear.html">https://www.sidefx.com/docs/houdini/render/linear.html</a></li>
</ul>
</li>
</ul>
<h3 id="circle을-사용한-각도설정"><a class="header" href="#circle을-사용한-각도설정">Circle을 사용한 각도설정</a></h3>
<ul>
<li>copytopoint로 circle을 점에 붙인다</li>
<li>carve의 U를 이용 각도를 가진 점을 얻고 - 포인트가 0부터 시작하는걸 변하게 하는게 좋을듯</li>
<li>점과 점을 merge</li>
<li>add로 선을 이어주자 - polygons &gt; By Group</li>
</ul>
<h3 id="어트리뷰트-비쥬얼라이제이션"><a class="header" href="#어트리뷰트-비쥬얼라이제이션">어트리뷰트 비쥬얼라이제이션</a></h3>
<ul>
<li>포인트 번호 표시해주는 툴바에 visualization 우클릭</li>
</ul>
<h3 id="디버그용-선을-이어보기"><a class="header" href="#디버그용-선을-이어보기">디버그용 선을 이어보기</a></h3>
<ul>
<li>어트리뷰트를 이용하여 정보용 점을 추가로 만들고</li>
<li>merge</li>
<li>Add&gt; By Group&gt; Add&gt; By Attribute&gt; Attribute Name 설정</li>
</ul>
<h3 id="grid를-텍스쳐로-굽기"><a class="header" href="#grid를-텍스쳐로-굽기">grid를 텍스쳐로 굽기</a></h3>
<ul>
<li><a href="https://blog.naver.com/checkjei/222622327344">https://blog.naver.com/checkjei/222622327344</a></li>
<li>geo &gt; grid / uvtexture / attribvop</li>
<li>Material Palette
<ul>
<li>Principled Shader 드래그</li>
<li>드래그된것 우클릭 파라미터 편집 색 조정및 기타 러프니스등 조정</li>
</ul>
</li>
<li>Network view 탭에서 out
<ul>
<li>baketexture 노드 생성</li>
<li>UV Object1에 geo노드 등록</li>
<li>Surface Unlit Base Color (basecolor) 선택</li>
</ul>
</li>
<li>Render to Disk 버튼 클릭</li>
</ul>
<h3 id="유니티-소스-컨트롤"><a class="header" href="#유니티-소스-컨트롤">유니티 소스 컨트롤</a></h3>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/unity/sourcecontrol.html">https://www.sidefx.com/docs/houdini/unity/sourcecontrol.html</a></li>
<li><UnityProject>/heu_session.txt : 현재 세션 정보를 저장하는 데 사용하는 임시 파일
<ul>
<li>.gitignore 할것</li>
</ul>
</li>
<li><UnityProject>/heu_settings.ini
<ul>
<li>이 파일에는 플러그인의 설정이 들어 있습니다</li>
</ul>
</li>
<li>폴더
<ul>
<li>Assets/Plugins/HoudiniEngineUnity/ : 플러그인</li>
<li>Assets/HoudiniEngineAssetCache/Working/
<ul>
<li>캐쉬폴더라서 사용자간 작업공유 안할꺼면 버전관리 안해도됨.</li>
<li>캐쉬라서 베이크안하면 날라감.</li>
<li>HoudiniEngine ▸ Plugin Settings ▸ GENERAL ▸ Houdini Asset Cache Path 해서 사용자별 버전관리해도 좋을듯</li>
</ul>
</li>
<li>Assets/HoudiniEngineAssetCacheBaked/
<ul>
<li>여기는 HDA에서 베이크된 에셋 파일이 생성되는 곳. 버전관리 해야함.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="두-점-가운데에-점-찍기"><a class="header" href="#두-점-가운데에-점-찍기">두 점 가운데에 점 찍기</a></h3>
<ul>
<li>subdivide로 가운데 점 찍고</li>
<li>delete
<ul>
<li>Operation: Non-selected</li>
<li>Entity: Point</li>
<li>Number
<ul>
<li>Operation : Delete by Range</li>
<li>Start/End : 1</li>
<li>Select _ of _ : 1 / 3</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<ul>
<li>지붕 널 만들때
<ul>
<li>remesh로 포인트 늘려주고 point jitter로 흩트려주면 좋음</li>
</ul>
</li>
<li>Lattice 사용
<ul>
<li>집 휜거 나타낼때
<ul>
<li>Bound를 잡고 임의의 Box로 가운데 점들을 그룹핑해서 Edit으로 휘어주고</li>
<li>Lattice를 사용해서 적용</li>
</ul>
</li>
<li>지붕 휜거는
<ul>
<li>Bound를 잡고 지붕마루 맡닿은 선을 polywire와 transform으로 영역을 만들어 그룹핑해서 Edit으로 휘어주고</li>
<li>Lattice를 사용해서 적용</li>
</ul>
</li>
</ul>
</li>
<li>건물에 인접한 점과 그렇지 않는 점
<ul>
<li>Attribute TransferDistance Threshold로 구할 수 있음.</li>
</ul>
</li>
<li>텐트모양
<ul>
<li>Box에 Facet(Post-Compute Normal)로 노말을 주고, Group(Keep By Normal)로 상단점을 선택후 Wrangle(@P.z = 0;)로 가운데로 뭉치고 Fuse로 중복을 없에 텐트모양을 만든다.</li>
</ul>
</li>
</ul>
<hr />
<h3 id="백틱--이름-활용-예제"><a class="header" href="#백틱--이름-활용-예제">백틱(``) : 이름 활용 예제</a></h3>
<pre><code class="language-txt">example_`rint(fit01(rand(detail("../foreach_begin2_metadata1/", "iteration", 0)), 1, 5))`
</code></pre>
<h3 id="성능-모니터"><a class="header" href="#성능-모니터">성능 모니터</a></h3>
<ul>
<li>Performance monitor pane
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/ref/panes/perfmon.html">https://www.sidefx.com/docs/houdini/ref/panes/perfmon.html</a></li>
<li>Windows &gt; Performance Monitor Alt + Y</li>
</ul>
</li>
</ul>
<h3 id="이동회전-행렬-활용"><a class="header" href="#이동회전-행렬-활용">이동/회전 행렬 활용</a></h3>
<pre><code class="language-vex">// matrix  maketransform(int trs, int xyz, vector t, vector r, vector s)
// matrix  maketransform(vector zaxis, vector yaxis, vector translate)

matrix location_matrix = maketransform(
    XFORM_TRS,
    XFORM_XYZ,
    p0,
    {0, 0, 0}
);
matrix rotation_matrix = maketransform(right, world_up, {0, 0, 0});
matrix m = rotation_matrix * location_matrix;

@P = invert(m);
@P = m;
</code></pre>
<h3 id="상단-면-중앙에-점-찍기"><a class="header" href="#상단-면-중앙에-점-찍기">상단 면 중앙에 점 찍기</a></h3>
<ul>
<li>vex 방식
<pre><code class="language-vex">if (@N.y &gt; 0.1)
{
    string prim_str = itoa(@primnum);
    vector center = getbbox_center(0, prim_str);
    addpoint(0, center);
}
</code></pre>
</li>
<li>노드 방식
<ul>
<li>blast/name/foreach(primitive)/extractcentroid 방식</li>
</ul>
</li>
</ul>
<h3 id="카메라를-통한-디버그-메시지-보여주기"><a class="header" href="#카메라를-통한-디버그-메시지-보여주기">카메라를 통한 디버그 메시지 보여주기</a></h3>
<ul>
<li>카메라노드에서 Edit Render Properties
<ul>
<li>Viewport Display &gt; OpenGL View &gt; Viewport Comment 추가해서 내용 입력하면 씬뷰에서 나타남. (``을 사용하여 vex코드 삽입가능)</li>
</ul>
</li>
</ul>
<h3 id="분홍색-마크"><a class="header" href="#분홍색-마크">분홍색 마크</a></h3>
<ul>
<li>Display Option : Marker
<ul>
<li>Set display option for : Tempalte Model Geometry 설정 바꿔주면 분홍색 마크시 보여지는거 달라지게 됨.</li>
</ul>
</li>
</ul>
<h3 id="이미지-카메라-매칭"><a class="header" href="#이미지-카메라-매칭">이미지 카메라 매칭</a></h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=qWD1nRqf2bk">Houdini Image Camera Matching</a>
<ul>
<li>houdini Perspective Match</li>
<li><a href="https://pixabay.com/photos/lost-places-hall-columns-pforphoto-2963764/">https://pixabay.com/photos/lost-places-hall-columns-pforphoto-2963764/</a></li>
<li><a href="https://fspy.io/">https://fspy.io/</a>
<ul>
<li><a href="https://github.com/stuffmatic/fSpy">https://github.com/stuffmatic/fSpy</a></li>
</ul>
</li>
<li><a href="https://www.andre-gaschler.com/rotationconverter/">https://www.andre-gaschler.com/rotationconverter/</a>
<ul>
<li>Input angle format / Output angle format을 Degree로 설정</li>
</ul>
</li>
<li>이미지를 fspy로 불러와서 앵글을 잡는다
<ul>
<li>Vanishing points axes
<ul>
<li>1 : x</li>
<li>2 : -z</li>
</ul>
</li>
</ul>
</li>
<li>후디니
<ul>
<li>카메라 View
<ul>
<li>bacgkround image에 이미지 깔아주고</li>
<li>resolution에 fspy Image Width/Height</li>
<li>aperture에 fspy Focal length - Sensor.x</li>
<li>Focal Length에 fspy Focal length - Value (mm)</li>
</ul>
</li>
<li>카메라 Transform
<ul>
<li>Translate:
<ul>
<li>fspy Camera position x/y/z</li>
</ul>
</li>
<li>Rotation
<ul>
<li>fspy의 Camera Orientation (Axis angle (degrees))를 rotationconverter에 복사(x/y/z/angle)</li>
<li>rotationconverter의 Axis with angle magnitude (radians) [x, y, z]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/Njordy/nLib">https://github.com/Njordy/nLib</a>
<ul>
<li><a href="https://www.youtube.com/watch?v=rVduzdrKYZg&amp;t=171s">https://www.youtube.com/watch?v=rVduzdrKYZg&amp;t=171s</a></li>
</ul>
</li>
</ul>
<h3 id="houdini_path"><a class="header" href="#houdini_path">HOUDINI_PATH</a></h3>
<ul>
<li>New Pane Tab Type &gt; Misc &gt; Textport
<ul>
<li>echo $HOUDINI_PATH</li>
</ul>
</li>
<li>New Pane Tab Type &gt; Python Shell
<ul>
<li>hou.getenv("HOUDINI_PATH")</li>
<li>hou.houdiniPath()</li>
</ul>
</li>
</ul>
<h3 id="뭔가-쌓인-효과"><a class="header" href="#뭔가-쌓인-효과">뭔가 쌓인 효과</a></h3>
<ul>
<li>Bound
<ul>
<li>Lower Padding : 적절히(0.1)</li>
<li>Upper Padding : 적절히(0.1)</li>
</ul>
</li>
<li>Group &amp; Blast
<ul>
<li>윗 영역을 구하고</li>
</ul>
</li>
<li>point N을 {0, -1, 0}</li>
<li>Scatter로 뿌려질 점들을 만들어주고</li>
<li>Ray로 원래 물체로
<ul>
<li>Ray Hit Group : rayHitGroup</li>
</ul>
</li>
<li>Blast : rayHitGroup</li>
<li>Fuse</li>
<li>VDB From Particle
<ul>
<li>Distance VDB 해제</li>
<li>Fog VDB</li>
<li>Point Radius Scale 올리고</li>
<li>Minimum Radius in Voxels 낮춰주고</li>
</ul>
</li>
<li>VDB Smooth</li>
<li>Volume VOP 으로 노이즈 주고</li>
<li>Convet VDB로 폴리곤으로</li>
<li>Poly Reduce</li>
<li>Normal</li>
</ul>
<h3 id="라인의-양쪽-선-구하기"><a class="header" href="#라인의-양쪽-선-구하기">라인의 양쪽 선 구하기</a></h3>
<ul>
<li>Sweep
<ul>
<li>Surface Shape : Ribbon</li>
<li>Columns : 1</li>
</ul>
</li>
<li>Add
<ul>
<li>Points : Delete Geometry But Keep the Points</li>
<li>Polygons / By Group
<ul>
<li>Add : Skip every Nth point</li>
<li>N : 2</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="나무-가지에-뭔가-걸치기"><a class="header" href="#나무-가지에-뭔가-걸치기">나무 가지에 뭔가 걸치기</a></h3>
<ul>
<li>Shrinkwrap로 나무 영역을 구해보고</li>
<li>Remesh to Grid로 잘개 쪼갠후</li>
<li>Attribute Blur로 부드럽게 해주자</li>
<li>Clip 으로 나무 기둥만큼 잘라주고</li>
<li>Scatter로 점뿌리기</li>
<li>Attribute Randomize로 속성 조정
<ul>
<li>ex) pscale, Cd</li>
</ul>
</li>
<li>그 다음 Copy to Point</li>
</ul>
<hr />
<h3 id="todo"><a class="header" href="#todo">TODO</a></h3>
<ul>
<li>
<p>blast</p>
<ul>
<li>@N.y=0</li>
<li>@P.y=0</li>
<li>@grp_a=hello</li>
</ul>
</li>
<li>
<p>공유된거</p>
<ul>
<li>Group - Include by Edges - Max Edge Angle 조절</li>
<li>Divide - Remove Shared Edges</li>
</ul>
</li>
</ul>
<p>vex연습</p>
<ul>
<li>
<p>chramp로 그리고 chi갯수만큼</p>
<ul>
<li>point 추가</li>
<li>primitive 추가</li>
</ul>
</li>
<li>
<p>pivot</p>
<ul>
<li>bbox(opinputpath(".", 0), D_XSIZE)</li>
<li>bbox(opinputpath(".", 0), D_YSIZE)</li>
<li>bbox(opinputpath(".", 0), D_ZSIZE)</li>
</ul>
</li>
<li>
<p>uv project 1</p>
<ul>
<li>wrangle ( detail )</li>
</ul>
</li>
</ul>
<p>vector size = getbbox_size(0);
if (size.x &gt; size.z)
{
@project_size = size.x;
}
else
{
@project_size = size.z;
}</p>
<ul>
<li>uv project
<ul>
<li>translate
<ul>
<li>centroid(opinputpath(".", 0), D_X)</li>
<li>centroid(opinputpath(".", 0), D_Y)</li>
<li>centroid(opinputpath(".", 0), D_Z)</li>
</ul>
</li>
<li>scale
<ul>
<li>detail(opinputpath(".", 0), "project_size", 0)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="주의"><a class="header" href="#주의">주의</a></h2>
<ul>
<li>파라미터에서 그룹과 관련된 수식 넣을때 주의
<ul>
<li>Blast// Group: <code>@Cd.r==0</code>와 <code>@Cd.r == 0</code>과는 다름</li>
</ul>
</li>
<li>그룹 날라가는 노드
<ul>
<li>Carve</li>
</ul>
</li>
</ul>
<h2 id="그룹"><a class="header" href="#그룹">그룹</a></h2>
<div class="table-wrapper"><table><thead><tr><th>타입</th><th>프리픽스</th><th>예시</th></tr></thead><tbody>
<tr><td>primitive</td><td>gr_pr_</td><td>gr_pr_building, gr_pr_tree</td></tr>
<tr><td>point</td><td>gr_pt_</td><td>gr_pt_crowd, gr_pt_dust</td></tr>
<tr><td>vertex</td><td>gr_vt_</td><td>gr_vt_borders, gr_vt_seams</td></tr>
<tr><td>edge</td><td>gr_ed_</td><td>gr_ed_support, gr_ed_bevel</td></tr>
</tbody></table>
</div>
<h2 id="trouble-shoot"><a class="header" href="#trouble-shoot">trouble shoot</a></h2>
<ul>
<li>HeightField에서 흰색판이 보이는 문제
<ul>
<li>벌칸렌더러의 문제로 보임
<ul>
<li><a href="https://www.reddit.com/r/Houdini/comments/1jloe5r/random_white_plane_using_terrainheightfield_tools/">https://www.reddit.com/r/Houdini/comments/1jloe5r/random_white_plane_using_terrainheightfield_tools/</a></li>
</ul>
</li>
<li>Edit &gt; Preferences &gt; 3D Viewports
<ul>
<li>Renderer : OpenGL 로 변경. 단, OpenGL로 변경시 변경사항이 잘 반영 안된다던지 다른 쪽에서 Viewport문제가 발생할 가능성이 있음.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="나선형helix"><a class="header" href="#나선형helix">나선형(Helix)</a></h3>
<ul>
<li>Point Wrangle : @N = {0, 1, 0};</li>
<li>Resample
<ul>
<li>curveu</li>
</ul>
</li>
<li>Poly Frame
<ul>
<li>tangentu</li>
<li>tangentv</li>
</ul>
</li>
</ul>
<pre><code class="language-vex">#include &lt;math.h&gt;

float resolution = chf("resolution");
float radius = chf("radius");

float u = fit01(@curveu, -PI, PI) * resolution;
vector pos = set(sin(u), cos(u), 0) * radius;
matrix3 t = set(v@N, v@tangentv, v@tangentu);

@P += pos * t;
</code></pre>
<ul>
<li>UV Texture
<ul>
<li>Texture Type: Uniform Spline</li>
<li>Attribute Class : Point</li>
</ul>
</li>
<li>Polyextrude
<ul>
<li>Transform Extrude Front</li>
<li>Translate 조절</li>
</ul>
</li>
<li>Point Wrangle
<ul>
<li>@uv.y = 1;</li>
</ul>
</li>
</ul>
<h2 id="전깃줄같이-선-연결시-양끝단의-점에-bevel써주면-좋음"><a class="header" href="#전깃줄같이-선-연결시-양끝단의-점에-bevel써주면-좋음">전깃줄같이 선 연결시 양끝단의 점에 bevel써주면 좋음</a></h2>
<p>foreach를 돌고 끝단을 그룹핑하며 나중에 Bevel.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="노드-1"><a class="header" href="#노드-1">노드</a></h1>
<h2 id="add"><a class="header" href="#add">Add</a></h2>
<ul>
<li>포인트 추가</li>
<li>포인트 제거
<ul>
<li>Polygons / Remove Unused Points</li>
</ul>
</li>
<li>포인트만 남기기 - 내부 선 지우기
<ul>
<li>Points / Delete Geometry But Keep the Points</li>
</ul>
</li>
<li>선만들기 - 점을 선으로 잇기
<ul>
<li>Polygons / By Group</li>
</ul>
</li>
<li>면만들기
<ul>
<li>Polygons / By Group
<ul>
<li>Closed 체크</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="transform"><a class="header" href="#transform">Transform</a></h2>
<ul>
<li>translate: -$CEX / -$CEY / -$CEZ</li>
<li>vex에서는 vector cent = getpointbbox_center(0);</li>
<li>바닥에서 띄우기
<ul>
<li>translate.y : -$YMIN</li>
</ul>
</li>
</ul>
<h2 id="box"><a class="header" href="#box">Box</a></h2>
<ul>
<li>Center.y : ch("sizey") * 0.5</li>
</ul>
<h2 id="line"><a class="header" href="#line">Line</a></h2>
<h3 id="width-line-x-dir-보통-sweep이랑-같이-쓰임"><a class="header" href="#width-line-x-dir-보통-sweep이랑-같이-쓰임">width line (x dir) 보통 sweep이랑 같이 쓰임</a></h3>
<ul>
<li>Origin.x : -ch("dist") * 0.5</li>
<li>Direction: 1/0/0</li>
</ul>
<h2 id="tube-1"><a class="header" href="#tube-1">Tube</a></h2>
<h3 id="바닥붙이기"><a class="header" href="#바닥붙이기">바닥붙이기</a></h3>
<ul>
<li>
<p>Center.y : ch("height") * 0.5</p>
</li>
<li>
<p>아니면 Transform 하나 써서</p>
<ul>
<li>translate.y : -$YMIN</li>
</ul>
</li>
</ul>
<h2 id="grid"><a class="header" href="#grid">Grid</a></h2>
<h3 id="평면상에서-점-흐트리기"><a class="header" href="#평면상에서-점-흐트리기">평면상에서 점 흐트리기</a></h3>
<ul>
<li>Grid</li>
<li>Attribute Expression
<ul>
<li>Attribute : N</li>
<li>VEXpression: @P</li>
</ul>
</li>
<li>Mountain</li>
</ul>
<h2 id="carve"><a class="header" href="#carve">Carve</a></h2>
<h3 id="first-u랑-second-u를-동기화"><a class="header" href="#first-u랑-second-u를-동기화">First U랑 Second U를 동기화</a></h3>
<ul>
<li>Second U : 1 - ch("domainu1")</li>
</ul>
<h3 id="선에서-가운데점만-뽑기"><a class="header" href="#선에서-가운데점만-뽑기">선에서 가운데점만 뽑기</a></h3>
<ul>
<li>First U : 0.5</li>
<li>Extract 탭 선택</li>
</ul>
<h2 id="group"><a class="header" href="#group">Group</a></h2>
<h3 id="group의-이름을-노드의-이름으로"><a class="header" href="#group의-이름을-노드의-이름으로">Group의 이름을 노드의 이름으로</a></h3>
<ul>
<li>Group Name : $OS</li>
<li>$OS : Operator String. Contains the current OP’s name. 노드 이름</li>
<li>H20.5 Legacy Preset &gt; Save As Permanent Defaults</li>
</ul>
<h4 id="선-양끝"><a class="header" href="#선-양끝">선 양끝</a></h4>
<ul>
<li>Group by Range
<ul>
<li>Group Type : Point
<ul>
<li>Start:1</li>
<li>End:1</li>
<li>Invert Range</li>
<li>Connectivity
<ul>
<li>Affect Disconnected Geometry Seperately</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="foreach-1"><a class="header" href="#foreach-1">Foreach</a></h2>
<h3 id="iteration-숫자-가져오기"><a class="header" href="#iteration-숫자-가져오기">iteration 숫자 가져오기</a></h3>
<ul>
<li>Create Meta Import Node</li>
<li>detail("../foreach_begin2_metadata1/", "iteration", 0)</li>
</ul>
<h2 id="switch"><a class="header" href="#switch">Switch</a></h2>
<h3 id="foreach의-iteration-숫자-가져다-쓰기"><a class="header" href="#foreach의-iteration-숫자-가져다-쓰기">Foreach의 iteration 숫자 가져다 쓰기</a></h3>
<ul>
<li>rand(detail("../foreach_begin2_metadata1/", "iteration", 0)) * opinputs(".")</li>
</ul>
<h3 id="첫번째는-기본-두번째는-object-merge로-가져다-쓸때"><a class="header" href="#첫번째는-기본-두번째는-object-merge로-가져다-쓸때">첫번째는 기본, 두번째는 Object Merge로 가져다 쓸때</a></h3>
<p>npoints(1) &gt; 0 로 포인트가 있으면 Object Merge를 가리키도록</p>
<h2 id="poly-frame"><a class="header" href="#poly-frame">Poly Frame</a></h2>
<h3 id="선의-tangent를-노말을-할당해서-노말이-선따라-가게"><a class="header" href="#선의-tangent를-노말을-할당해서-노말이-선따라-가게">선의 Tangent를 노말을 할당해서 노말이 선따라 가게</a></h3>
<ul>
<li>TangentName: N</li>
</ul>
<h2 id="orient-along-curve"><a class="header" href="#orient-along-curve">Orient Along Curve</a></h2>
<ul>
<li>Frame
<ul>
<li>Tangent Type : Next</li>
<li>Tangent Up Vector : Y Axis</li>
</ul>
</li>
</ul>
<h2 id="라인에-있는-점-지우기"><a class="header" href="#라인에-있는-점-지우기">라인에 있는 점 지우기</a></h2>
<ul>
<li>Facet으로 Remove Inline Points 하거나</li>
<li>Refine으로 Unrefine탭 사용</li>
</ul>
<h2 id="띄엄띄엄-선"><a class="header" href="#띄엄띄엄-선">띄엄띄엄 선</a></h2>
<ul>
<li>라인을 Resample</li>
<li>Convert Line으로 점사이를 primitive로 변환</li>
<li>Carve
<ul>
<li>First U: 알아서 조절</li>
<li>Second V: 1-ch("domainu1")</li>
</ul>
</li>
</ul>
<h2 id="라인에-원하는-수만큼-점-추가"><a class="header" href="#라인에-원하는-수만큼-점-추가">라인에 원하는 수만큼 점 추가</a></h2>
<ul>
<li>Resample
<ul>
<li>Maximum Segment Length 체크해제</li>
<li>Maximum Segments 체크하기</li>
</ul>
</li>
</ul>
<h2 id="링형을-sweep시-시작-끝을-부분이-끊기는-현상-해결-open-curve-issue"><a class="header" href="#링형을-sweep시-시작-끝을-부분이-끊기는-현상-해결-open-curve-issue">링형을 sweep시 시작-끝을 부분이 끊기는 현상 해결 (Open Curve Issue)</a></h2>
<ul>
<li>
<p>방법 1</p>
<ul>
<li>시작-끝 부분을 이어버리는것</li>
<li>Fuse / PolyFrame / Sweep</li>
</ul>
</li>
<li>
<p>방법 2</p>
<ul>
<li>시작-끝 부분의 노말을 동기화</li>
<li>PolyFrame 으로 선의 Tangent를 노말을 할당해서 노말이 선따라 가게하고
<ul>
<li>TangentName: N</li>
</ul>
</li>
<li>Wrangle (detail) 로 끝점의 노말을 시작 점의 노말로 셋팅한다
<pre><code class="language-vex">vector first_N = point(0, "N", 0);
int last_pnt = npoints(0) - 1;
setpointattrib(0, "N", last_pnt, first_N);
</code></pre>
</li>
<li>Sweep</li>
</ul>
</li>
<li>
<p>원인</p>
<ul>
<li>Fuse를 안했거나</li>
<li>Ends에서 Unroll with New Points로 새 포인트를 넣을 경우</li>
</ul>
</li>
</ul>
<h2 id="링-2개-사이-채우기"><a class="header" href="#링-2개-사이-채우기">링 2개 사이 채우기</a></h2>
<p>링 하나가 프리미티브 하나라고 가정</p>
<ul>
<li>Group: Edges 으로 A/B를 지정</li>
<li>Merge</li>
<li>Poly Bridge
<ul>
<li>Group : A
<ul>
<li>Divide Into : Individual Elements</li>
<li>Reverse Winding</li>
</ul>
</li>
<li>Group : B
<ul>
<li>Divide Into : Individual Elements</li>
<li>Reverse Winding</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="라인-점에서-선마다-프리미티브-붙이기"><a class="header" href="#라인-점에서-선마다-프리미티브-붙이기">라인 점에서 선마다 프리미티브 붙이기</a></h2>
<ul>
<li>Convert Line을 사용하거나</li>
<li>Carv를 이용함
<ul>
<li>First U : 0</li>
<li>Second U : 1</li>
<li>Break Points
<ul>
<li>Cut At Internal U Breakpoints</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="스택"><a class="header" href="#스택">스택</a></h2>
<ul>
<li>Copy And Transform
<ul>
<li>Translate.y : bbox(0, D_YSIZE)</li>
</ul>
</li>
</ul>
<h2 id="uv-texture"><a class="header" href="#uv-texture">UV Texture</a></h2>
<p>Texture Type : Arc Length Spline
Attribute Class : Point
Scale.x : arclen(0, 0, 0, 1)</p>
<h2 id="poly-wire"><a class="header" href="#poly-wire">Poly Wire</a></h2>
<p>Edit Parameter Interface - Ramp(wradious)랑 Float(radious_mult)추가하고
Wire Radious: chramp("wradious", $BBY, 0) * chf("radious_mult");</p>
<h2 id="에너지실드같은-벌집모양"><a class="header" href="#에너지실드같은-벌집모양">에너지실드같은 벌집모양</a></h2>
<p>Sphere만들고, Divide에서 Compute Dual체크</p>
<h2 id="rbd"><a class="header" href="#rbd">RBD</a></h2>
<ul>
<li>글자같은건 RBD Pack 하면 좋음</li>
<li>RBD Bullet Solver 에서 Collision - Ground Collision: Ground Plane 가 있음.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vex-1"><a class="header" href="#vex-1">Vex</a></h1>
<h3 id="자잘한-팁"><a class="header" href="#자잘한-팁">자잘한 팁</a></h3>
<ul>
<li>switch같은곳은 작아서 Ctrl+E로 확대해서 편집하자</li>
<li>if(a==b, 1, 2) 같은 식으로 넣을 수 도 있음.</li>
</ul>
<h3 id="ramp이용한-프로파일"><a class="header" href="#ramp이용한-프로파일">Ramp이용한 프로파일</a></h3>
<p>1번 오리지날</p>
<pre><code class="language-vex">int point_arr[];

float profile = chramp("profile", 1);
int pointCount = chi("./profile");

for (int i = 1; i &lt;= pointCount; ++i)
{
    float p_pos = ch("./profile" + itoa(i) + "pos");
    float p_val = ch("./profile" + itoa(i) + "value");
    int new_point = addpoint(0, set(p_pos, p_val, 0));
    append(point_arr, new_point);
}

addprim(0, "polyline", point_arr);
</code></pre>
<p>2번 - 간편</p>
<pre><code class="language-vex">// 간편한 버전 Line - Resample 후
float perc = (float)@ptnum / (@numpt - 1);
float ramp = chramp("ramp", perc);
@P.y = y;
</code></pre>
<h3 id="현재-노드-이름"><a class="header" href="#현재-노드-이름">현재 노드 이름</a></h3>
<pre><code class="language-vex">string current_node_name = split(opfullpath("."), "/")[-1]; // $OS
</code></pre>
<h3 id="라인에서-사이-각-구하기"><a class="header" href="#라인에서-사이-각-구하기">라인에서 사이 각 구하기</a></h3>
<pre><code class="language-vex">int ptnum_prev;
int ptnum_next;

int ptnum_last = npoints(0) - 1;
if (@ptnum  == 0)
{
    ptnum_prev = ptnum_last;
    ptnum_next = 1;
}
else if (@ptnum == ptnum_last)
{
    ptnum_prev = ptnum_last - 1;
    ptnum_next = 0;
}
else
{
    ptnum_prev = @ptnum - 1;
    ptnum_next = @ptnum + 1;
}


vector pos_prev = point(0, "P", ptnum_prev);
vector pos_next = point(0, "P", ptnum_next);

vector dir_prev = normalize(@P - pos_prev);
vector dir_next = normalize(@P - pos_next);

float angle = degrees(acros(dot(dir_prev, dir_next)));
</code></pre>
<h3 id="라인-방향-설정"><a class="header" href="#라인-방향-설정">라인 방향 설정</a></h3>
<pre><code class="language-vex">// 일단 PolyFrame사용해서 Tangent:N 설정해주고,
// Wrangle(poitn)후 Visualize의 Marker&amp;Vector로 right은 빨강, up은 초록

vector dir = @N;
dir.y = 0;
dir = normalize(dir);
v@right = cross(dir, {0, 1, 0});
v@up = cross(v@right, @N);
</code></pre>
<h3 id="find_reveresed_prims"><a class="header" href="#find_reveresed_prims">find_reveresed_prims</a></h3>
<pre><code class="language-vex">vector nrm = primuv(0, "N", @primnum, {0.5,0.5,0});
if(nrm.y &lt; 0)
{
    i@group_reverse = 1;
}
</code></pre>
<h3 id="0--1-구간-반복"><a class="header" href="#0--1-구간-반복">0 ~ 1 구간 반복</a></h3>
<pre><code class="language-vex">float y = abs((x % 2) - 1);
</code></pre>
<h3 id="엇갈려서-선을-이을때"><a class="header" href="#엇갈려서-선을-이을때">엇갈려서 선을 이을때</a></h3>
<pre><code class="language-vex">//아니면 그냥 Connect Adjacent Pieces도 고려해볼것

vector p1_arr[];
for(int i = 0; i &lt; npoints(0); i++)
{
    vector p1 = point(1, "P", i);
    append(p1_arr, p1);
}

for (int i = 0; i &lt; npoints(0); ++i)
{
    int idx = i + 1;
    if (idx == npoints(0))
    {
        idx = 0;
    }

    vector p1 = p1_arr[idx];
    int newpt = addpoint(0, p1);
    addprim(0, "polyline", i, newpt);
}

return;

// 역방향일 경우
// - 위 vex에서 1번을 sort노드로 shift의 offset을 -1로
// - 아래 vex를 사용
for (int i = 0; i &lt; npoints(0); ++i)
{
    int idx = i - 1;
    if (idx &lt; -1)
    {
        idx = npoints(0) - 1;
    }

    vector p1 = p1_arr[idx];
    int newpt = addpoint(0, p1);
    addprim(0, "polyline", i, newpt);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="플러그인"><a class="header" href="#플러그인">플러그인</a></h1>
<ul>
<li><a href="http://cgtoolbox.com/houdini-expression-editor/">외부에디터</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipes"><a class="header" href="#recipes"><a href="https://www.sidefx.com/docs/houdini/network/recipes.html">Recipes</a></a></h1>
<p>Recipes: saving and recreating node and parameter presets</p>
<p>Windows &gt; Recipe Manager</p>
<p>%HOME%/houdini{version}/otls/Recipes.hdanc</p>
<p>노드 선택 &gt; Recipes
&gt; Save Selected Items as Tool...
&gt; Save Selected Items as Decoration...
&gt; Save Node Preset...</p>
<p>tools
decorations
parameter presets</p>
<p><a href="https://youtu.be/SBIhd9rpf7Y">Baking Sexy Recipes | Attila Torok | Houdini 20.5 HIVE Paris</a></p>
<p><a href="https://www.youtube.com/watch?v=o1xg202Rbg8">Getting Started with Recipes | Houdini 20.5</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="단어장"><a class="header" href="#단어장">단어장</a></h1>
<h2 id="후디니"><a class="header" href="#후디니">후디니</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody>
<tr><td>bevel</td><td>비스듬한 면</td><td>노드</td></tr>
<tr><td>seam</td><td>경계선, 이음매</td><td></td></tr>
<tr><td>Lattice</td><td>격자, 격자모양</td><td>이 노드로 공간 왜곡같은 효과 주는게 가능</td></tr>
<tr><td>cusp</td><td>(두 곡선이 만나는 뾰족한) 끝</td><td>Normal 노드에서 angle 조절</td></tr>
<tr><td>vein</td><td>정맥, (식물의) 잎맥, 돌결, 나뭇결</td><td>Point VOP에서 사용가능한 노드</td></tr>
<tr><td>subdivision</td><td>다시 나눔, 세분</td><td>노드</td></tr>
<tr><td>Curvature</td><td>곡률</td><td>Labs Measure Curvature노드</td></tr>
<tr><td>Tubulent</td><td>난류 - 유체의 흐름이 바르지 않고 상하좌우로 섞이면서 흐르는 것</td><td>Tubulent Noise</td></tr>
<tr><td>intrinsic</td><td>내재적인, 고유의, 본질적인</td><td></td></tr>
<tr><td>shrink wrap</td><td>수축 포장</td><td>노드</td></tr>
<tr><td>Vellum</td><td>양피지</td><td>ex) Vellum Hair 노드</td></tr>
<tr><td>Wedge</td><td>쐐기</td><td>TOP</td></tr>
<tr><td>erode</td><td>침식/풍화 되다</td><td></td></tr>
<tr><td>slump</td><td>침체/무너진</td><td></td></tr>
<tr><td>sediment</td><td>침전/퇴적물</td><td></td></tr>
<tr><td>debris</td><td>지형이 무너질 때 생기는 잔해/쓰레기</td><td></td></tr>
<tr><td>bedrock</td><td>기반/기반암</td><td></td></tr>
<tr><td>sweep</td><td>쓸기/ 휘두름</td><td></td></tr>
</tbody></table>
</div>
<h2 id="crease---주름-주름이-생기게-하다"><a class="header" href="#crease---주름-주름이-생기게-하다">crease - 주름, 주름이 생기게 하다</a></h2>
<p>Ledge - (벽에서 튀어나온) 선반, 돌출부.
Beam - 기둥
Truss - 트러스(지붕·교량 따위를 버티기 위해 떠받치는 구조물)
Pillar - (다리·건물 지붕 등을 받치는, 특히 장식 겸용의 둥근) 기둥
Plank - 널빤지
Shingle - 조약돌, 지붕널, 대상 포진
Chimney - 굴뚝
annual rings, tree ring - 나이테
Foliage  -</p>
<p>profile - 윤곽, (얼굴의) 옆모습
Skew - 왜곡하다, 비스듬히 움직이다</p>
<p>직각삼각형 right-angled triangle
밑변 B base
빗변 H hypotenuse
수직 P perpendicular</p>
<p>topology 폴리곤 구조와 배열
retopology 토폴리지 재구성
principled - 절조 있는, 원칙에 입각한</p>
<p>ridge - 등 / 봉우리 / 튀어나온 부분</p>
<p>Angle of repose : 안식각, 휴식각 또는 임계 안식각. 이 각도에서 경사면의 재료는 미끄러지기 직전이다.</p>
<p>spherify - 구형화하다
trunk - 나무의 몸통</p>
<ul>
<li>isosurface
<ul>
<li>등치선의 3차원 형태이며, 3차원에서 일정한 스칼라 값(예: 압력, 온도, 속도, 밀도)을 갖는 점들의 모임을 나타내는 연속된 표면이다. 등가면은 컴퓨터 그래픽의 주요 주제이며, 특히 전산 유체 역학에서 시각화 방법으로 자주 사용된다.</li>
<li>iso- → 같다, 동일하다 (equal)</li>
<li>surface → 표면, 면 (surface)</li>
<li>그래서 isosurface란 → "어떤 3D 공간 안에서 특정 값이 동일한 지점을 연결한 면" 을 말해.</li>
</ul>
</li>
</ul>
<p>isometry - 등거리 변환
sliver - (깨지거나 잘라 낸) 조각 - Divide 노드</p>
<p>pre (미리) + fabricated (제작된)</p>
<p>skirt 1.	(가장자리를) 두르다
dilate - 확장[팽창]하다[시키다], 키우다[커지다]
Splat - A splat map is a texture which controls blending of multiple textures (or other values) across a model.
scaffolding 높은 곳에서 작업할 수 있게 가설(임시로 설치)한 플랫폼 혹은 구조물</p>
<p>Rebar (철근)
Steel Reinforcement (강철 보강재)
Reinforcing Bar (보강 바)
concave - 오목한 (↔convex)</p>
<p>chipping - a small fragment of stone, wood, or similar material</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="https://www.sidefx.com/faq/question/houdini-engine-plugin-free-for-unity-and-ue4/">https://www.sidefx.com/faq/question/houdini-engine-plugin-free-for-unity-and-ue4/</a></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>HOUDINI ENGINE</th><th></th><th></th></tr></thead><tbody>
<tr><td>for Unity/Unreal</td><td>.hda</td><td>최대 10개</td></tr>
<tr><td>INDIE</td><td>.hda .hdalc</td><td>최대 3대</td></tr>
<tr><td>EDUCATION</td><td>.hda .hdalc .hdanc</td><td></td></tr>
<tr><td>APPRENTICE</td><td>X</td><td></td></tr>
</tbody></table>
</div>
<ul>
<li><a href="https://www.sidefx.com/docs/houdini/unity/">https://www.sidefx.com/docs/houdini/unity/</a></li>
<li><a href="https://github.com/sideeffects/HoudiniEngineForUnity">https://github.com/sideeffects/HoudiniEngineForUnity</a></li>
<li><a href="https://www.sidefx.com/download/daily-builds/">https://www.sidefx.com/download/daily-builds/</a></li>
<li><a href="https://www.sidefx.com/products/compare/">https://www.sidefx.com/products/compare/</a></li>
</ul>
<p>APPRENTICE</p>
<ul>
<li>Houdini Engine for Unity 사용 안됨</li>
<li>렌더링 시 1280x720으로 제한</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>FBX</td><td>Import</td></tr>
<tr><td>Alembic</td><td>Import</td></tr>
<tr><td>.bgeo</td><td>import/export</td></tr>
<tr><td>.obj</td><td>import/export</td></tr>
</tbody></table>
</div>
<p>Houdini Engine Plug-ins x
Create Assets for Engine x</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
